<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ViewBinding]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F04%2F26%2FViewBinding%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[手机平台出现的问题记录]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F04%2F01%2FAndroid%2F%E4%B8%8A%E7%BA%BF%2F%E6%89%8B%E6%9C%BA%E5%B9%B3%E5%8F%B0%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[一些手机平台出现的问题记录小米手机使用smartrefresh和scrollview的时候，进入页面会自动往下滚动一些距离没有置顶。解决方法是选择顶部的视图 ，让其获得焦点 xml: android:focusable=&quot;true&quot; android:focusableInTouchMode=&quot;true&quot; 代码中： xxx.requestFocus()]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[第三方相关遇见问题的整理]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F03%2F29%2FAndroid%2FLibrary%2F%E7%AC%AC%E4%B8%89%E6%96%B9%E7%9B%B8%E5%85%B3%E9%81%87%E8%A7%81%E9%97%AE%E9%A2%98%E7%9A%84%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[第三方的库或者功能遇见的问题整理微信如果都配置好了 报错无效的appid，那么重置一下。遇到这个问题是原来ios那边创建应用并加入，我android这边是后面去加入的，就需要重置一下]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>libs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle字段解析]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F03%2F23%2Fframework%2FGradle%E5%AD%97%E6%AE%B5%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Gradle字段解析annotationProcessor和android-apt：注解处理 annotationProcessor&amp;android-apt：Java编译时注解处理器 kapt:Kotlin译时注解处理器 APT：Annotation Processing Tool 的简称，处理注解的工具，可以在代码编译期解析注解，并生成新的Java文件，减少手动代码的输入。比如Dagger2，ButterKnife, EventBus3等 annotationProcessor和android-apt的功能是一样的，它们是替代关系。 Gradle2.2发布之后，annotationProcessor来代替android-apt、 kotlin中不使用apt和annotationProcessor，使用kapt（Annotation Processing for Kotlin ） kapt：kotlin注解处理器插件 会有提示If you are using Kotlin, replace annotationProcessor with kapt. kotlin-kapt不是Android Gradle 内置插件需要额外引入 apply plugin: &apos;kotlin-kapt&apos; 例子： //java中 implementation &apos;com.google.dagger:dagger:2.17&apos; annotationProcessor &apos;com.google.dagger:dagger-compiler:2.17&apos; //kotlin中 implementation &apos;com.google.dagger:dagger:2.17&apos; kapt &apos;com.google.dagger:dagger-compiler:2.17&apos; 插眼 插眼-看懂编译注解annotationProcessor和kapt]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ButterKnife]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F03%2F23%2FAndroid%2FLibrary%2FButterKnife%2F</url>
    <content type="text"><![CDATA[ButterKnife基本配置： android { ... // Butterknife requires Java 8. compileOptions { sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8 } } dependencies { implementation &apos;com.jakewharton:butterknife:10.2.3&apos; annotationProcessor &apos;com.jakewharton:butterknife-compiler:10.2.3&apos; } module使用需要配置： 根目录下build.gradle: buildscript { repositories { mavenCentral() google() } dependencies { classpath &apos;com.jakewharton:butterknife-gradle-plugin:10.2.3&apos; } } module下build.gradle apply plugin: &apos;com.android.library&apos; apply plugin: &apos;com.jakewharton.butterknife&apos; 使用R2（注意模块下的资源文件仍然用R，用R2会报异常找不到;但是bindView用R2,点击的注册id时R2，比较id是R） class ExampleActivity extends Activity { @BindView(R2.id.user) EditText username; @BindView(R2.id.pass) EditText password; ... } ButterKnife module中使用的坑]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>lib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView（三）]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F03%2F19%2FAndroid%2FUI%2Fwidget%2Fnative%2FWebView%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Webview加载css样式用string拼接css样式 //原网页内容 String bodyHTML = &quot;&lt;link rel=\&quot;stylesheet\&quot; href=\&quot;file:///android_asset/content.css\&quot; type=\&quot;text/css\&quot;&gt;&quot;; String head = &quot;&lt;head&gt;&lt;style&gt;img{max-width: 100%; width:auto; height: auto;}&lt;/style&gt;&lt;/head&gt;&quot;; String resultContent&quot; = &lt;html&gt;&quot; + head + &quot;&lt;body&gt;&quot; + bodyHTML + &quot;&lt;/body&gt;&lt;/html&gt;&quot;; webview.loadDataWithBaseURL(null, body, &quot;text/html&quot;, &quot;UTF-8&quot;, null);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>widget</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决github打不开问题]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F03%2F19%2FGit%2FGithub%2F%E8%A7%A3%E5%86%B3Github%E6%89%93%E4%B8%8D%E5%BC%80%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[解决github打不开问题github最近的ip和cdn有变化，就会导致国内的用户无法登陆 github网址查询：https://github.com.ipaddress.com/ github域名查询：https://fastly.net.ipaddress.com/github.global.ssl.fastly.net github静态资源ip：https://github.com.ipaddress.com/assets-cdn.github.com 通过以上网址确定github的最新ip，分别记录复制v4Address，然后修改电脑的host文件 host文件位置： winR运行：C:\WINDOWS\system32\drivers\etc host文件附上下面的内容（最新v4address） 140.82.112.4 github.com 199.232.69.194 github.global.ssl.fastly.net 185.199.108.153 assets-cdn.github.com 185.199.110.153 assets-cdn.github.com 185.199.111.153 assets-cdn.github.com 插眼：Win10怎么修改hosts文件 插眼：解决Github打不开问题]]></content>
      <categories>
        <category>github</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ScrollView记录]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F03%2F19%2FAndroid%2FUI%2Fwidget%2Fnative%2FScrollView%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[ScrollView1、Scrollview始终显示滚动条 scrollview的:android:fadeScrollbars=&quot;false&quot; 表示始终显示垂直滚动条 2、解决Recyclerview和 NestedSrollview的滑动冲突 NestedSrcollview: android:fillViewport=&quot;true&quot; RecycleView: android:layout_height=&quot;wrap_content&quot; android:nestedScrollingEnabled=&quot;false&quot;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>widget</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发中git分支管理]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F03%2F13%2FGit%2FGit%2F%E5%BC%80%E5%8F%91%E4%B8%ADgit%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[开发中git分支管理master/main : 主分支，只可合并，不可修改，保存每个上线版本完整代码release : 各个版本发布代码的版本，版本发布完成之后合并至masterdevelop： 开发专用,功能提测完成无误之后合并至release分支，并在release分支打包发布feat-xxx/vxxx: 功能或者版本开发分支,功能提测完成之后合并至developfix ：bug修复，从属于develop分支；保持和develop代码同步，修复完成后合并至develop Tag格式为： MajorVersion.MinorVersion.FixVersion-TypeLabelTypeLabel为 alpha、 beta、 devel。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云课堂项目重构遇到的所有问题]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F03%2F09%2Fframework%2F%E4%BA%91%E8%AF%BE%E5%A0%82%E9%A1%B9%E7%9B%AE%E9%87%8D%E6%9E%84%E9%81%87%E5%88%B0%E7%9A%84%E6%89%80%E6%9C%89%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[云课堂项目重构遇到的所有问题上层module报错找不到依赖module下的aar文件，明明aar文件就放在lib下面插眼 1、引入aar文件需要： 引入的module build.gradle中添加 android { ... repositories { flatDir { dirs &apos;libs&apos; } } } 2、该module下的build.gradle 添加 dependencies implementation(name: &apos;name-of-aar&apos;, ext: &apos;aar&apos;) 3、报错找不到，全局添加： project下的build.gradle allprojects { repositories { google() jcenter() flatDir { //所有的module的repositories下把library module中的libs目录添加到依赖关系中 dirs project(&apos;:引入了aar的module名字&apos;).file(&apos;libs&apos;) } } } 4、module修改包名（主要是R的生成路径）：直接在manifest中修改包名即可，尽量保证路径和包名一致避免出现未知问题，也更加统一 5、每个模块单独存放对应模块的页面，在manifest中声明对应的activity，每个模块需要给出需要的权限 6、Attribute category#${JPUSH_PKGNAME}@name at AndroidManifest.xml requires a placeholder substitution but no value for &lt;JPUSH_PKGNAME&gt; is provided. 7、Attribute meta-data#JPUSH_CHANNEL@value value=(developer-default) from [:module_cloudclass] AndroidM 出错原因是在module中配置项目需要的极光解决方法： ManifestPlacholders配置放在app的build下 在你的app中把jpush的compile去掉，保留ManifestPlacholders的配置，引用lib，然后把jpush的相关配置在lib里面再配置一下(compile:&apos;cn.jiguang.xxx&apos;和ManifestPlacholders都配置一下)。 lib里面的ManifestPlacholders可以随意填写。最终生效的还是app里面的。 多module下 Application 不要设置label 至设置app下的label应用名 8、模块有优先级，同名资源文件会根据结构有限来选择，重构的时候发现appname变成了某个库的名字，代码中看到又没问题，这种情况直接在app中设置appname字段就没问题了]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Kotlin随手笔记]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F03%2F09%2FKotlin%2FKotlin%E9%9A%8F%E6%89%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Kotlin随手笔记强制类型转换 as基础类型转换： toInt()、toFloat()异常捕获是一样另外记录：异常finally字段：是无论异常发生不发生，最终都会执行的代码。 for 循环：for(xxx in yyy) {} 循环的本次结束和中断和java一样通过continue和break xx.forEach() 这种写法，编译器无法识别 break, continue 关键字了,需要使用其他招式。 //待补充 静态常量：java写法： public class SystemConstat{ /** * 静态常量 */ public static final String SUCCESS_VAL = &quot;success&quot;; /** * 静态变量 */ public static String CHANGE_VAL = &quot;change&quot;; } kotlin写法: class SystemConstat{ companion object{ /** * 相当于Java的static */ var SUCCESS_CHANGE = &quot;CHANGE&quot;; /** * 相当于Java的 public final static */ const val SUCCESS_PUBLIC = &quot;PUBLIC&quot; /** * 相当于Java的 private final static */ val SUCCESS_PRIVATE = &quot;PRIVATE&quot; } } 复合符号、判空符号 ?. ?: !! as? ‘?’?.是如下代码的简化： foo?.bar if (foo != null){ return foo.bar() }else{ return null } ?: foo?:bar if (foo != null){ return foo }else{ return bar } foo as? type if(foo is Type){ foo as Type }else{ null } foo!! if(foo!=null){ foo }else{ NullPointException } ? Type? @nullable+Type Type @NotNull+Type 参考：[Kotlin (一) 复合符号( &apos;?.&apos; &apos;?:&apos; &apos;!!&apos; &apos;as?&apos; &apos;?&apos; )](https://blog.csdn.net/lckj686/article/details/80448471?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control) 三目运算符kotlin中没有三目运算法，替代方法为： 直接用if else 模式 ，如： if(a&gt;b) a else b 循环数组全部循环： for（i:Int in list）{ ... } 指定区间循环，比如只要数组的1到末尾： var range = 1..10 区间是[1,10] var range = 1 util list.size() 区间是 [1,list.size()) for(i in range){ ... } mvp缺点 当想复用model或者present的时候，会有很多空的方法体，因为A页面用到 b页面不一定用到打包之前三件事：版本号是否更新、服务器地址是否生成、日志log是否关闭、混淆是否开启]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arouter(二)]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F03%2F09%2FAndroid%2FLibrary%2FArouter%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Arouter(二)自动注入传递参数（对象）自动注入需要写 ARouter.getInstance().inject(this) 否则为空 如果不需要自动注入可以不写，写的话可以写基类中 @JvmField //如果是kotlinbean类才添加 @Autowired(name = &quot;ownerDashBoard&quot;) var ownerDashBoardBean: OwnerDashBoardBean? = null Fragment1、其他模块获取未依赖模块的Fragment // 获取Fragment Fragment fragment = (Fragment) ARouter.getInstance().build(&quot;/test/fragment&quot;).navigation(); 常见报错 Execution failed for task ‘:BaseLib:kaptDebugKotlin’.A failure occurred while executing org.jetbrains.kotlin.gradle.internal.KaptExecutionjava.lang.reflect.InvocationTargetException (no error message) 解决：检查每个库的AROUTER_MODULE_NAME是否配置，并且注解版本号要一致 如果报错无法找到路径，那么对照发生的原因，还有就是混合编码（java+kotlin）的module配置要对，包含kotlin的就用kapt方式报错Arouter error: duplicate class遇见这个情况怎么重新配置都没用，后来发现是因为重构拖拽文件时，界面文件会附带一个viewbinding的新建类，这个就是重复的，全部删除即可 ARouter::There is no route match the path [/training/workFragment], in group [training][ ]这里获取fragment为空，由提示可知，不在同一个module下的最好是别用一个组名 打包的时候 报错提示 Program type already present java.lang.RuntimeException: java.lang.RuntimeException: com.android.builder.dexing.DexArchiveMergerException: Error while merging dex archives:Learn how to resolve the issue at https://developer.android.com/studio/build/dependencies#duplicate_classes.Program type already present: com.alibaba.android.arouter.routes.ARouter$$Group$$app 说明arouter下有组名重复，重复组名是app(ARouter$$Group$$app)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>libs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ImmersionBar]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F03%2F05%2FAndroid%2FLibrary%2FImmersionBar%2F</url>
    <content type="text"><![CDATA[ImmersionBarImmersionBar – android 4.4以上沉浸式实现依赖// 基础依赖包，必须要依赖 implementation &apos;com.gyf.immersionbar:immersionbar:3.0.0&apos; 使用ImmersionBar.with(this).init();//可以放在基类activity中 设置ImmersionBar.with(this) .transparentStatusBar() //透明状态栏，不写默认透明色 .transparentNavigationBar() //透明导航栏，不写默认黑色(设置此方法，fullScreen()方法自动为true) .transparentBar() //透明状态栏和导航栏，不写默认状态栏为透明色，导航栏为黑色（设置此方法，fullScreen()方法自动为true） .statusBarColor(R.color.colorPrimary) //状态栏颜色，不写默认透明色 .navigationBarColor(R.color.colorPrimary) //导航栏颜色，不写默认黑色 .barColor(R.color.colorPrimary) //同时自定义状态栏和导航栏颜色，不写默认状态栏为透明色，导航栏为黑色 .statusBarAlpha(0.3f) //状态栏透明度，不写默认0.0f .navigationBarAlpha(0.4f) //导航栏透明度，不写默认0.0F .barAlpha(0.3f) //状态栏和导航栏透明度，不写默认0.0f .statusBarDarkFont(true) //状态栏字体是深色，不写默认为亮色 .navigationBarDarkIcon(true) //导航栏图标是深色，不写默认为亮色 .autoDarkModeEnable(true) //自动状态栏字体和导航栏图标变色，必须指定状态栏颜色和导航栏颜色才可以自动变色哦 .autoStatusBarDarkModeEnable(true,0.2f) //自动状态栏字体变色，必须指定状态栏颜色才可以自动变色哦 .autoNavigationBarDarkModeEnable(true,0.2f) //自动导航栏图标变色，必须指定导航栏颜色才可以自动变色哦 .flymeOSStatusBarFontColor(R.color.btn3) //修改flyme OS状态栏字体颜色 .fullScreen(true) //有导航栏的情况下，activity全屏显示，也就是activity最下面被导航栏覆盖，不写默认非全屏 .hideBar(BarHide.FLAG_HIDE_BAR) //隐藏状态栏或导航栏或两者，不写默认不隐藏 .addViewSupportTransformColor(toolbar) //设置支持view变色，可以添加多个view，不指定颜色，默认和状态栏同色，还有两个重载方法 .titleBar(view) //解决状态栏和布局重叠问题，任选其一 .titleBarMarginTop(view) //解决状态栏和布局重叠问题，任选其一 .statusBarView(view) //解决状态栏和布局重叠问题，任选其一 .fitsSystemWindows(true) //解决状态栏和布局重叠问题，任选其一，默认为false，当为true时一定要指定statusBarColor()，不然状态栏为透明色，还有一些重载方法 .supportActionBar(true) //支持ActionBar使用 .statusBarColorTransform(R.color.orange) //状态栏变色后的颜色 .navigationBarColorTransform(R.color.orange) //导航栏变色后的颜色 .barColorTransform(R.color.orange) //状态栏和导航栏变色后的颜色 .removeSupportView(toolbar) //移除指定view支持 .removeSupportAllView() //移除全部view支持 .navigationBarEnable(true) //是否可以修改导航栏颜色，默认为true .navigationBarWithKitkatEnable(true) //是否可以修改安卓4.4和emui3.x手机导航栏颜色，默认为true .navigationBarWithEMUI3Enable(true) //是否可以修改emui3.x手机导航栏颜色，默认为true .keyboardEnable(true) //解决软键盘与底部输入框冲突问题，默认为false，还有一个重载方法，可以指定软键盘mode .keyboardMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE) //单独指定软键盘模式 .setOnKeyboardListener(new OnKeyboardListener() { //软键盘监听回调，keyboardEnable为true才会回调此方法 @Override public void onKeyboardChange(boolean isPopup, int keyboardHeight) { LogUtils.e(isPopup); //isPopup为true，软键盘弹出，为false，软键盘关闭 } }) .setOnNavigationBarListener(onNavigationBarListener) //导航栏显示隐藏监听，目前只支持华为和小米手机 .setOnBarListener(OnBarListener) //第一次调用和横竖屏切换都会触发，可以用来做刘海屏遮挡布局控件的问题 .addTag(&quot;tag&quot;) //给以上设置的参数打标记 .getTag(&quot;tag&quot;) //根据tag获得沉浸式参数 .reset() //重置所以沉浸式参数 .init(); //必须调用方可应用以上所配置的参数 遇到的问题1、当白色背景状态栏遇到不能自动改变状态栏字体为深色的设备时，解决方案： 设置深色字体： ImmersionBar.with(this) .statusBarDarkFont(true, 0.2f) //原理：如果当前设备支持状态栏字体变色，会设置状态栏字体为黑色，如果当前设备不支持状态栏字体变色，会使当前状态栏加上透明度，否则不执行透明度 .init();]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>lib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android命名规范]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F03%2F05%2FAndroid%2FStandard%2FAndroid%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[Android&amp;Java命名规范1、变量命名 严禁使用中文或者中文拼音进行重命名 使用驼峰式命名风格（单词最好控制在三个以内） 局部变量应用作用来命名 // 命名规范附带技巧（当布局中同个类型的控件只有一个的时候，也可以这样命名） TextView textView; RecyclerView recyclerView; 成员变量必须以小m开头，如： String mName; TextView mNameView; FrameLayout mNameLayout; 布尔值不应该以is开头，如 // 错误写法示例 private boolean mIsDebug = false; boolean isDebug = false; // 正确写法示例 private boolean mDebug = false; boolean debug = false; 静态变量用小s开头，如： static Handler sHandler; 静态常量全大写 static final String REQUEST_INSTALL_PACKAGES; 2、方法命名initXX： 初始化相关方法，使用 init 为前缀标识，如初始化布局 initView isXX： 方法返回值为 boolean 型的请使用 is 或 check 为前缀标识 getXX： 返回某个值的方法，使用 get 为前缀标识，例如 getName setXX： 设置某个属性值，使用 set 为前缀标识，例如 setName handleXX/processXX： 对数据进行处理的方法，例如 handleMessage displayXX/showXX： 弹出提示框和提示信息，例如 showDialog updateXX： 更新某个东西，例如 updateData saveXX： 保存某个东西，例如 saveData resetXX： 重置某个东西，例如 resetData clearXX： 清除某个东西，例如 clearData removeXX： 移除数据或者视图等，例如 removeView drawXX： 绘制数据或效果相关的，使用 draw 前缀标识，例如 drawText 3、类文件命名业务模块，以 模块 + 类型 命名，如： HomeActivity.java SettingFragment.java HomeAdapter.java AddressDialog.java 技术模块请以类的 作用 来命名，如： CrashHandler.java GridSpaceDecoration.java PickerLayoutManager.java 4、接口命名监听事件：参考View的写法和命名 public class View { private View.OnClickListener mListener; public void setOnClickListener(OnClickListener listener) { mListener = listener; } public interface OnClickListener { void onClick(View v); } } 回调事件：参考Handler的学法和命名 public class Handler { public interface Callback { boolean handleMessage(Message msg); } } 5、布局文件命名以 模块 + 类型 来命名，如 home_activity.xml setting_fragment.xml menu_item.xml address_dialog.xml 这样写的好处在于，由于 res 文件夹下是没有层级概念的,通过前缀的命名可以帮助我们更好定位到同一模块下的资源 例如分享对话框中，有对话框 Root 布局和 Item 布局 share_dialog.xml（Root 布局） share_item.xml（Item 布局） 6、drawable资源文件命名以 模块 + 作用 + 类型命名, 如 user_round_shape.xml user_text_selector button_rect_selector.xml（通用直角按钮样式） button_round_selector.xml（通用圆角按钮样式） 7、图标命名以 模块 + 作用 + 类型 命名，（作用背景用bg，普通图片用ic，）如： share_ic_link.png（复制链接） share_ic_moment.png（分享到朋友圈） share_ic_qq.png（分享到 QQ 好友） share_ic_qzone.png（分享到 QQ 空间） share_bg_wechat.png（分享到微信好友） 8、String ID命名以模块 + 功能来命名，如： &lt;!-- 主界面 --&gt; &lt;string name=&quot;home_nav_index&quot;&gt;首页&lt;/string&gt; &lt;string name=&quot;home_nav_found&quot;&gt;发现&lt;/string&gt; &lt;string name=&quot;home_nav_message&quot;&gt;消息&lt;/string&gt; &lt;string name=&quot;home_nav_me&quot;&gt;我的&lt;/string&gt; &lt;string name=&quot;home_exit_hint&quot;&gt;再按一次退出&lt;/string&gt; &lt;!-- 登录界面 --&gt; &lt;string name=&quot;login_register&quot;&gt;注册&lt;/string&gt; &lt;string name=&quot;login_phone_hint&quot;&gt;请输入手机号&lt;/string&gt; &lt;string name=&quot;login_password_hint&quot;&gt;请输入密码&lt;/string&gt; &lt;string name=&quot;login_forget&quot;&gt;忘记密码？&lt;/string&gt; &lt;string name=&quot;login_text&quot;&gt;登录&lt;/string&gt; &lt;string name=&quot;login_other&quot;&gt;其他登录方式&lt;/string&gt; 9、View ID命名以 控件的缩写 + 模块名 + 作用 来命名，如： @+id/R.id.rg_login_type @+id/R.id.et_login_phone @+id/R.id.et_login_sms @+id/R.id.et_login_password @+id/R.id.btn_login_commit 常用控件缩写： TextView tvEditText etButton btnImageView ivImageButton ibListView lvRecyclerView rvRadioButton rbRadioGroup rgProgressBar pbCheckBox cbTableLayout tlScrollView svLinearLayout llRelativeLayout rlFrameLayout fl 10、Style命名与主题相关的样式，以Theme命名结尾，控件样式以Style命名结尾，要求尽量简洁并且需要有代码注释，如： Theme: &lt;!-- 应用主题样式 --&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.DayNight.NoActionBar&quot;&gt; ..... &lt;/style&gt; &lt;!-- 全屏主题样式 --&gt; &lt;style name=&quot;FullScreenTheme&quot; parent=&quot;AppTheme&quot;&gt; ..... &lt;/style&gt; &lt;!-- 闪屏页主题样式 --&gt; &lt;style name=&quot;SplashTheme&quot; parent=&quot;FullScreenTheme&quot;&gt; ..... &lt;/style&gt; 控件： &lt;!-- 默认圆角按钮样式 --&gt; &lt;style name=&quot;ButtonStyle&quot; parent=&quot;Widget.AppCompat.Button.Borderless&quot;&gt; ..... &lt;/style&gt; &lt;!-- 不带圆角按钮样式 --&gt; &lt;style name=&quot;RectButtonStyle&quot; parent=&quot;ButtonStyle&quot;&gt; ..... &lt;/style&gt; &lt;!-- 默认文本框样式 --&gt; &lt;style name=&quot;EditTextStyle&quot;&gt; ..... &lt;/style&gt; &lt;!-- 验证码按钮样式 --&gt; &lt;style name=&quot;CountdownViewStyle&quot;&gt; ..... &lt;/style&gt; 11、color以color+ 色值来命名，不建议以作用来命名，会有很多重复的，如： &lt;color name=&quot;color_FF8B33&quot;&gt;#FF8B33&lt;/color&gt; &lt;color name=&quot;color_FEF6F1&quot;&gt;#FEF6F1&lt;/color&gt; &lt;color name=&quot;color_EFF5FA&quot;&gt;#EFF5FA&lt;/color&gt; &lt;color name=&quot;color_399BF1&quot;&gt;#399BF1&lt;/color&gt; &lt;color name=&quot;color_F0FAF6&quot;&gt;#F0FAF6&lt;/color&gt; 插眼 插眼GitHUb]]></content>
      <categories>
        <category>standard</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F03%2F05%2FMine%20Todo%2FRecyclerView%2F</url>
    <content type="text"><![CDATA[RecyclerView所有的因为复用造成的问题，都可以用数据来解决，因为数据是不会因为复用而改变的。所以保存记录数据 禁止复用： 1、普通adapter中：viewHolder.setIsRecyclable(false);那么这个Item的onViewRecycled将永远不会调用。 2、万能adapter中：在convert()中的viewHolder.setIsRecyclable(false);那么这个Item的onViewRecycled将永远不会调用。 3、如果你的界面出现了错乱的现象，请调用如上代码可能能简单粗暴的解决，当然代价是损失少许的性能表现了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2FAaronYang23.github.io%2F2021%2F03%2F05%2FAndroid%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%9C%E8%A5%BF%E6%80%BB%E7%BB%93%2FString%2F</url>
    <content type="text"><![CDATA[title: Stringdate: 2021-03-05 16:35:46categories: Javatags: todo: String APIindexOfindexOf(String str) //第一次出现str的位置 indexOf(String str, int fromIndex) // 从fromIndex开始 第一次出现str的位置 lastIndexOf(String str) //最后出现str的位置 lastIndexOf(String str, int fromIndex) //从fromIndex开始 最后出现str的位置 subStringsubstring（int beginIndex）： 返回一个新的字符串，它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。 substring(int beginIndex,int endIndex) ：返回一个新字符串，它是此字符串的一个子字符串。该子字符串从指定的 beginIndex 处开始，直到索引 endIndex - 1 处的字符。因此，该子字符串的长度为 endIndex-beginIndex String、StringBuilder和StringBuffer速度： StringBuilder&gt;StringBuffer&gt;String 线程安全： StringBuffer 总结： String：适用于少量的字符串操作的情况 StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况 StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况]]></content>
  </entry>
  <entry>
    <title><![CDATA[MVVM]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F02%2F05%2Fframework%2FMVVM%2F</url>
    <content type="text"><![CDATA[完整的MVVM设计模式的例子(使用RecyclerView) Android MVVM-编程思想 ViewModel的封装 Android模块解耦之组件化实现之踩坑 1、BaseViewmodel因为viewmodel最好是不要持有View(Activity)的引用,所以要定义一系列基础的可以调用activityUI的方法，这里通过livedata设置 2、 按照功能页面去划分路径]]></content>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView遇到的问题]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F02%2F05%2FRecyclerView%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[RecyclerView用bean数据记录控件状态，不要用view中的字段去记录，因为view会复用 显示会不准确 动态高度item 数据串动例子：根据文字的长度来判断显示高度，并且点击查看更多可展开，因为复用会造成的情况 ,这种设置数据又怎么去控制 item是webview展示富文本 需求是如果webview高度没超过最大高度就自适应，超过最大高度就只显示最大高度显示可以查看更多按钮]]></content>
  </entry>
  <entry>
    <title><![CDATA[Retrofit]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F02%2F05%2FAndroid%2FLibrary%2FRetrofit%2F</url>
    <content type="text"><![CDATA[RxJava2出现:Unable to create call adapter for io.reactivex.Flowablehttps://www.cnblogs.com/tonycheng93/p/6346466.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[项目重构和组件化开发的记录]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F02%2F05%2F%E9%A1%B9%E7%9B%AE%E9%87%8D%E6%9E%84%E5%92%8C%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E7%9A%84%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[小结1、先说说为什么要重构项目架构： 因为手上的旧项目已经经历了2年多，三个人，其中包含2种代码风格，语言环境包含java和kotlin。然后有个实训模块是以前的一个app，然后迁移到应用中作为一个模块了，估计为了开发进度并没有对重复页面和资源还有代码进行处理，导致阅读很是复杂；项目结构复杂，第一个版本是最基础版的mvc开发模式，第二个加入的实训是mvp模式。 项目间依赖耦合严重，并且因为多语言环境的问题。gradle的配置很容易出问题，不熟悉的情况下处理甚是麻烦，所以决定要重构，并且加入最新的掌握的技术。采用MVVM+databinding+组件化的开发模式。然后想法还是多模块，不分多工程，毕竟模块的配置要熟悉一点 遇到的各类问题 模块依赖结构： 基本上一些问题的处理都是为了解决低层次的module无法跳转或者使用高层次依赖的页面或者方法： 2、页面间的通信：主要是为解决低层次的module跳转高层次的页面：Arouter 3、全局Application： 集成baseApplication 放到common库中，一些需要用的字段放大base里声明，比如 islogin https://blog.csdn.net/qq_20369621/article/details/106202998 插眼：插眼：终于懂了” 系列：Android组件化，全面掌握！]]></content>
  </entry>
  <entry>
    <title><![CDATA[Gradle问题收录]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F02%2F05%2Fframework%2FGradle%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Gradle相关问题收录gradle无法下载远程依赖问题&amp;插件无法下载1、新建显目报错，无法加载依赖问题： 解决办法： 参考1 1.添加上全部远程仓库 repositories { google() mavenCentral() jcenter() } allprojects { repositories { google() jcenter() mavenCentral() } } 2.关闭gradle离线模式，检查http代理的设置。之前出现过因为上一个项目设置的离线和本地http代理，然后新建项目之后无法正常依赖，即使设置了不启动http代理也还是一直无法依赖，连不上网，后来看错误信息发现还是本地的127的代理，发现是因为全局的gradle.propertis那里还没有变，删除掉那些代理设置就好下图表示一个为全局的设置一个为项目的设置 下图表示全局的配置依然还是本地的http代理 2、Android Studio error: Unable to start the daemon process的解决方法方法一：删除 C:\Users\UserName\.gradle 目录，重新启动 Android Studio即可。重启动后，它会自动为你创建一个新的。 方法二：修改配置。File -&gt; Settings. 选择左边导航栏的Compiler项，设置 VM Options 为 -Xmx512m即可。 方法三：其它应该，留出更多的内存空间试试。 3、警告‘annotationProcessor’ dependencies won’t be recognized as kapt annotation processors. Please change the configuration name to ‘kapt’ for these artifacts: ‘com.airbnb:deeplinkdispatch-processor:4.1.0’. 处理： 需要把annotationProcessor切换为kapt就可以了。 api &apos;com.github.bumptech.glide:glide:4.9.0&apos; annotationProcessor &apos;com.github.bumptech.glide:compiler:4.9.0&apos; 修改为： api &apos;com.github.bumptech.glide:glide:4.9.0&apos; kapt &apos;com.github.bumptech.glide:compiler:4.9.0&apos; 5、gradle 编译出现错误，并且提示 NO Message 时，用gradle命令查看更多log运用gradle 命令： Run with --stacktrace Run with --info or --debug option to get more log output. 4、如果项目无法执行gradlew command提示java环境变量相关问题，如果没有安装jdk需要安装jdk，然后把对应的JAVA_HOME和PATH环境变量配置正确，配置完成后需要重启Studio，不然还是会报错误。重启后用指令去检查路径和版本 java -version javac -version echo $JAVA_HOME$ gadlew -version]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[屏幕总结]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F02%2F02%2F%E5%B1%8F%E5%B9%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[屏幕适配相关必须了解的做个总结屏幕相关参数:dp/dip : Density independent pixels ，设备无关像素。 Android中的长度大小，以前是dip，现在写作dp dpi : dots per inch 单位英寸内像素点数量,即像素密度 density : 直译密度，但是这里我们可以理解为缩放比,与屏幕密度相关 ，就是dpi/160 得到的值 分辨率： 横纵2个方向的像素点的数量，长边上的像素 x 宽边上的像素 资源文件夹下的图片尺寸: mdpi : 120 ~ 160 dpihdpi : 160 ~ 240 dpixhdpi: 240 ~ 320 dpixxhdpi :320 ~ 480 dpixxxhdpi:480 ~ 640 dpi dip設置與分辯率無關,但写屏幕密度有关.在默认情况下, LDPI密度为120,系数为0.75, MDPI的密度为160,系数为1.0； HDPI的密码为240,系数为1.5； XHDPI的密度为320,系数为2.0； dpi计算：知道分辨率，知道屏幕尺寸，用勾股定理算出对角线长度对应的像素数量 再除以屏幕尺寸 即是单位英寸的像素点数量 这是适配主流手机的 非主流的还是要根据当前手机去计算得出 然后取对应文件下的图 density 如何计算 ，如何放图 ，放哪个文件夹下的图 根据UI的设计稿尺寸 计算出density是多少 然后对应找到是哪个dpi 然后就放对应下的图片即可 屏幕的缩放比是多少： dpi文字SP的计算方式，换算成像素是多少px 图片宽度 dp 是多少px protected int dp2px(float dp) { final float scale = mContext.getResources().getDisplayMetrics().density; return (int) (dp * scale + 0.5f); } protected int sp2px(float sp) { final float scale = this.mContext.getResources().getDisplayMetrics().scaledDensity; return (int) (sp * scale + 0.5f); } 插眼]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java项目调用Kotlin库或者类会遇到的问题]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F02%2F02%2FKotlin%2FJava%E9%A1%B9%E7%9B%AE%E8%B0%83%E7%94%A8Kotlin%E5%BA%93%E6%88%96%E8%80%85%E7%B1%BB%E4%BC%9A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1、java调用kotlin，文件存在但是运行编译报错找不到包和文件在创建的Android项目中,所选语言是Java时，默认是不支持kotlin的。所以如果在这个时候调用kotlin语言的库或者类，不会提示报错，但是运行或者rebuild的时候会提示找不到类。原因就是需要转译： 处理： 在对应需要调用的model首行下添加语句 apply plugin: &apos;kotlin-android&apos; apply plugin: &apos;kotlin-android-extensions&apos; 这个时候会报找不到插件。还需要将项目支持插件,只需要根build.gradle下添加： buildscript { ext.kotlin_version = &apos;1.3.72&apos; ... dependencies{ classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot; ... } 插眼]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Arouter]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F02%2F01%2FAndroid%2FLibrary%2FArouter%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[官方文档一、添加依赖和配置： Java环境 //All Mudule android { defaultConfig { ... //注意：这块代码必须每个模块都加上，不管有没有引用 //AROUTER_MODULE_NAME这个跟版本有关，低版本是小写的 javaCompileOptions { annotationProcessorOptions { arguments = [AROUTER_MODULE_NAME: project.getName()] } } } } //Need Arouter Module dependencies { // 替换成最新版本, 需要注意的是api // 要与compiler匹配使用，均使用最新版可以保证兼容 compile &apos;com.alibaba:arouter-api:x.x.x&apos; // 因为上面说compile 其他模块都可以引用，但是下面compiler必须需要路由的model都引用(主要是没法api声明) //被跳转的模块或者说使用了ARouter注解的模块都要加上这个 annotationProcessor &apos;com.alibaba:arouter-compiler:x.x.x&apos; ... } 混合编码和Kotlin android { defaultConfig { ... kapt { arguments { arg(&quot;AROUTER_MODULE_NAME&quot;, project.getName()) } } } } 依赖： compile &apos;com.alibaba:arouter-api:x.x.x&apos; kapt &apos;com.alibaba:arouter-compiler:x.x.x&apos; 二、基本使用查看官方文档 不做记录// 构建标准的路由请求 ARouter.getInstance().build(&quot;/home/main&quot;).navigation(); // 构建标准的路由请求，并指定分组a ARouter.getInstance().build(&quot;/home/main&quot;, &quot;ap&quot;).navigation(); // 构建标准的路由请求，startActivityForResult // navigation的第一个参数必须是Activity，第二个参数则是RequestCode ARouter.getInstance().build(&quot;/home/main&quot;, &quot;ap&quot;).navigation(this, 5); // 直接传递Bundle Bundle params = new Bundle(); ARouter.getInstance() .build(&quot;/home/main&quot;) .with(params) .navigation(); // 指定Flag ARouter.getInstance() .build(&quot;/home/main&quot;) .withFlags(); .navigation(); // 获取Fragment Fragment fragment = (Fragment) ARouter.getInstance().build(&quot;/test/fragment&quot;).navigation(); // 对象传递 ARouter.getInstance() .withObject(&quot;key&quot;, new TestObj(&quot;Jack&quot;, &quot;Rose&quot;)) .navigation(); // 觉得接口不够多，可以直接拿出Bundle赋值 ARouter.getInstance() .build(&quot;/home/main&quot;) .getExtra(); // 转场动画(常规方式) ARouter.getInstance() .build(&quot;/test/activity2&quot;) .withTransition(R.anim.slide_in_bottom, R.anim.slide_out_bottom) .navigation(this); // 转场动画(API16+) ActivityOptionsCompat compat = ActivityOptionsCompat. makeScaleUpAnimation(v, v.getWidth() / 2, v.getHeight() / 2, 0, 0); // ps. makeSceneTransitionAnimation 使用共享元素的时候，需要在navigation方法中传入当前Activity ARouter.getInstance() .build(&quot;/test/activity2&quot;) .withOptionsCompat(compat) .navigation(); // 使用绿色通道(跳过所有的拦截器) ARouter.getInstance().build(&quot;/home/main&quot;).greenChannel().navigation(); // 使用自己的日志工具打印日志 ARouter.setLogger(); // 使用自己提供的线程池 ARouter.setExecutor(); 三、项目中的规划2个方案 1.统一ArouterPathConstants类管理所有路径，方便修改只需要修改变量即可2.分模块创建对应的PathConstants类，然后所有类可以集合放在一个module中，这样做是如文章所说，避免所有人员可操作base库 四、遇到的问题： 因为一开始搭框架，主modeleapp暂时还没有依赖其他模块，导致一直报错找不到路径，哎 所以请看你 主App的build.gradle中，是否把你需要路由的模块引入进来，果你模块没引入进来，那么Arouter铁定找不到 其他原因： &quot;W/ARouter::: ARouter::There is no route match the path [/xxx/xxx], in group [xxx][ ]&quot; 通常来说这种情况是没有找到目标页面，目标不存在 如果这个页面是存在的，那么您可以按照下面的步骤进行排查 1、检查目标页面的注解是否配置正确，正确的注解形式应该是 (@Route(path=&quot;/test/test&quot;), 如没有特殊需求，请勿指定group字段，废弃功能) 2、检查目标页面所在的模块的gradle脚本中是否依赖了 arouter-compiler sdk (需要注意的是，要使用apt依赖，而不是compile关键字依赖) 3、检查主app是否依赖了其他组件module，没有依赖上肯定找不到 4、检查编译打包日志，是否出现了形如 ARouter::�Compiler &gt;&gt;&gt; xxxxx 的日志，日志中会打印出发现的路由目标 启动App的时候，开启debug、log(openDebug/openLog), 查看映射表是否已经被扫描出来，形如 D/ARouter::: LogisticsCenter has already been loaded, GroupIndex[4]，GroupIndex &gt; 0]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>libs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecycleView - 分割线（ItemDecoration）]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F01%2F29%2FRecycleView-%E5%88%86%E5%89%B2%E7%BA%BF%EF%BC%88ItemDecoration%EF%BC%89%2F</url>
    <content type="text"><![CDATA[RecycleView - item间距（ItemDecoration） RecyclerView中没有直接设置item间距的方法，要想实现间距，方式有2种 1、通过设置item布局去设置间距，然后手动设置第一个和最后一个的间距2、通过代码设置item根布局的layoutparams，设置其margin2、通过使用自定义ItemDecoration 第一种方式不记录了。第一种方式麻烦，看起来也不舒服美观，这里记录ItemDecoration的使用方法 Grid设置间距//设置边距 public static class SpaceItemDecoration extends RecyclerView.ItemDecoration { private final int normal; //基本边距，设置为0 private final int margin; //间距数值 @Override public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) { super.getItemOffsets(outRect, view, parent, state); outRect.top = normal;//上边距 outRect.bottom = normal;//下边距 if (parent.getChildAdapterPosition(view) % 3 == 0) { outRect.right = normal; outRect.left = margin; } else if (parent.getChildAdapterPosition(view) % 3 == 1) { outRect.right = margin; outRect.left = margin; } else if (parent.getChildAdapterPosition(view) % 3 == 2) { outRect.right = normal; outRect.left = margin; } } public SpaceItemDecoration(int normal, int margin) { this.normal = normal; this.margin = margin; } } ... 然后recycler设置： mRecycler.addItemDecoration(new RecycleItemsDecortion.SpaceItemDecoration(0, 15)); 参考：https://blog.csdn.net/briblue/article/details/70161917 https://blog.csdn.net/briblue/article/details/70211942]]></content>
  </entry>
  <entry>
    <title><![CDATA[Gradle在Android中的更多配置]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F01%2F29%2Fframework%2FGradle%E5%9C%A8Android%E4%B8%AD%E7%9A%84%E6%9B%B4%E5%A4%9A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Gradle的更多配置一、总是依赖最新版本库有时候库依赖的时候会报警告，提示有新的版本，为了避免每次提示的警告，选择直接一直依赖最新版本的库写法： implementation &apos;com.google.ar:core:latest.release&apos; //关键是冒号后边的latest.release代表最新，替代具体的某个版本号 但是要注意一直依赖最新的话，到时候可能会出现一些问题，比如某些方法过时并删除了；还有兼容等问题 二、主module引用依赖module，却无法使用依赖module里的依赖库的解决办法主要场景存在于模块化开发中，模块A include 模块b，确无法使用模块B以依赖的其他aar包中的类的时候。 解决方式： 1、将模块B依赖的implemention改成api 例如： api &quot;com.squareup.retrofit2:retrofit:2.5.0&quot; 2、将include改为 api 例如： api project(&quot;:framework&quot;) 因为implemention声明的依赖只能在本module内使用，跨module使用就要使用api声明 参考：https://blog.csdn.net/wc0000000/article/details/103164278]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git提交规范]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F01%2F23%2FGit%2FGit%2FGit%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[Git提交描述规范feat：添加新特性、新功能（feature） fix：修补bug docs：文档改变（documentation） style： 代码格式改变，不改变代码逻辑（不影响代码运行的变动） refactor：代码重构，没有加新功能或者修复bug perf: 优化相关，比如提升性能、体验（performance profiling） test：增加测试代码 chore：改变构建流程、或者增加依赖库、关联包升级、工具等 revert: 回滚到上一个版本 //自定义,博客用 add: 添加博客 update: 更新原有博客]]></content>
  </entry>
  <entry>
    <title><![CDATA[Glide]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F01%2F23%2FAndroid%2FLibrary%2FGlide%2F</url>
    <content type="text"><![CDATA[glide设置banner加载出来的图片fixXY，加载失败holder占位图Center_CropGlide.with(mContext.getApplicationContext()) .applyDefaultRequestOptions(new RequestOptions().error(R.mipmap.logo_loading).placeholder(R.mipmap.logo_loading).dontAnimate()) // .asBitmap() .listener(new RequestListener&lt;Bitmap&gt;() { //通过监听来设置imageview的scaletype @Override public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Bitmap&gt; target, boolean isFirstResource) { holder.imageView.setScaleType(ImageView.ScaleType.CENTER_CROP); return false; } @Override public boolean onResourceReady(Bitmap resource, Object model, Target&lt;Bitmap&gt; target, DataSource dataSource, boolean isFirstResource) { holder.imageView.setScaleType(ImageView.ScaleType.FIT_XY); return false; } }) .centerCrop() // .load(data.getAdvertImage()) .load(mContext.getDrawable(R.mipmap.logo_loading)) .into(holder.imageView);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Gradle-配置全局依赖config.gradle]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F01%2F23%2Fframework%2FGradle-%E9%85%8D%E7%BD%AE%E5%85%A8%E5%B1%80%E4%BE%9D%E8%B5%96config-gradle%2F</url>
    <content type="text"><![CDATA[项目配置全局依赖config为什么要配置全局：1、方便管理多模块下依赖库的版本统一,构建版本的统一，避免一些兼容性发生的异常2、清晰化整个项目依赖内容，也包含了项目的版本信息3、顺便学习下gradle的一些语法使用 配置过程1、项目根目录下创建config.gradle内容参照： ext { android = [ compileSdkVersion: 30, //整形不用引号 非整形用单引号包裹 buildToolsVersion: &apos;30.0.2&apos;, minSdkVersion : 23, targetSdkVersion : 30, versionCode : 1, versionName : &quot;1.0&quot; ] config = [ // 不显示Log GLOBAL_LOG_DEBUG : &quot;true&quot;, GLOBAL_USE_CANARY: &quot;false&quot;, ] //第三方库版本 version = [ retrofitSdkVersion : &quot;2.6.0&quot;, glideSdkVersion : &quot;4.11.0&quot;, butterknifeSdkVersion : &quot;10.1.0&quot;, rxlifecycleSdkVersion : &quot;1.0&quot;, rxlifecycle2SdkVersion: &quot;2.2.2&quot;, espressoSdkVersion : &quot;3.2.0&quot;, canarySdkVersion : &quot;1.6.3&quot; ] dependencies = [ ... //support &quot;appcompat-x&quot; : &apos;androidx.appcompat:appcompat:1.1.0&apos;, &quot;constraintlayout&quot; : &apos;androidx.constraintlayout:constraintlayout:1.1.3&apos;, &quot;design&quot; : &apos;com.google.android.material:material:1.1.0&apos;, &quot;recyclerview-v7&quot; : &apos;androidx.recyclerview:recyclerview:1.0.0&apos;, &quot;navigation-fragment&quot; : &apos;androidx.navigation:navigation-fragment:2.2.2&apos;, &quot;navigation-ui&quot; : &apos;androidx.navigation:navigation-ui:2.2.2&apos;, //test &quot;junit&quot; : &apos;junit:junit:4.+&apos;, &quot;ext:junit&quot; : &apos;androidx.test.ext:junit:1.1.1&apos;, &quot;espresso-core&quot; : &quot;com.android.support.test.espresso:espresso-core:${version[&quot;espressoSdkVersion&quot;]}&quot;, //jetpack &quot;livedata&quot; : &apos;androidx.lifecycle:lifecycle-livedata-ktx:2.2.0&apos;, &quot;viewmodel&quot; : &apos;androidx.lifecycle:lifecycle-viewmodel-ktx:2.2.0&apos;, //network //&quot;retrofit&quot; : &quot;com.squareup.retrofit2:retrofit:${version[&quot;retrofitSdkVersion&quot;]}&quot;, // &quot;glide-loader-okhttp3&quot; : &quot;com.github.bumptech.glide:okhttp3-integration:${version[&quot;glideSdkVersion&quot;]}&quot;, //view &quot;recyclerViewAdapterHelper&quot;: &quot;com.github.CymChad:BaseRecyclerViewAdapterHelper:3.0.3&quot;, &quot;immersionbar&quot; : &quot;com.gyf.immersionbar:immersionbar:3.0.0&quot;, ... ] } 2、项目引用config.gradle 项目下的build.gradle文件顶部添加 apply from: &quot;config.gradle&quot; 3、各module下的build.gradle 引用config,其实就是指向了config.gradle参考: plugins { id &apos;com.android.application&apos; } android { def config = rootProject.ext.android //像定义一个变量，相当于简写路径，和http填root地址类似 compileSdkVersion config.compileSdkVersion buildToolsVersion config.buildToolsVersion defaultConfig { applicationId &quot;com.yyx.bluetest&quot; minSdkVersion config.minSdkVersion targetSdkVersion config.targetSdkVersion versionCode config.versionCode versionName config.versionName testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot; } ... } dependencies { def lib = rootProject.ext.dependencies //module依赖 implementation project(path: &apos;:Http&apos;) implementation project(path: &apos;:commonLib&apos;) implementation project(path: &apos;:commonWidget&apos;) implementation project(path: &apos;:baseLib&apos;) //库依赖 implementation lib[&apos;appcompat-x&apos;] implementation lib.design implementation lib.constraintlayout implementation lib[&apos;navigation-fragment&apos;] //有特殊符号的用中括号加单引号，没有特殊符号的可以直接用 lib. implementation lib[&apos;navigation-ui&apos;] implementation lib.livedata implementation lib.viewmodel //测试依赖 testImplementation lib.junit androidTestImplementation lib[&apos;ext:junit&apos;] androidTestImplementation lib[&apos;espresso-core&apos;] } 配置buildConfigField buildConfigField可以用来定义全局使用的一些变量，常用来设置LOG_DEBUG 设置位置在 module -&gt; build.gradle -&gt; android -&gt; defaultConfig中配置，也可以在buildTypes为不同的编译类型配置 ps： 1、可以分模块使用,但是一般是放在app的build.gradle做全局使用 2、buildConfigField可以配置java的基本类型，比如Integer，boolean，还有String等，还可以配置数组 3、可以配合config.gradle 统一放在config中归纳所有配置 android{ ... defaultConfig{ ... //Log显示 //buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, rootProject.ext.config[&quot;GLOBAL_LOG_DEBUG&quot;] //buildConfigField &quot;boolean&quot;, &quot;USE_CANARY&quot;, rootProject.ext.config[&quot;GLOBAL_USE_CANARY&quot;] //buildConfigField &quot;boolean&quot;, &quot;PAY_SANDBOX&quot;, rootProject.ext.config[&quot;PAY_SANDBOX&quot;] ... } ... buildTypes { release { // 不显示Log buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, rootProject.ext.control[&quot;GLOBAL_LOG_DEBUG&quot;] buildConfigField &quot;boolean&quot;, &quot;USE_CANARY&quot;, rootProject.ext.control[&quot;GLOBAL_USE_CANARY&quot;] ... } debug { // 不显示Log buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, rootProject.ext.control[&quot;GLOBAL_LOG_DEBUG&quot;] buildConfigField &quot;boolean&quot;, &quot;USE_CANARY&quot;, rootProject.ext.control[&quot;GLOBAL_USE_CANARY&quot;] ... } } ... }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F01%2F23%2FComputerSystem%2FWindows%2FWindows%E6%8C%87%E4%BB%A4%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Windows指令收集关闭端口号所对应的进程：mac 在控制台输入 sudo lsof -i:端口号 //查看被占用进程的pid sudo kill -9 pid //杀死进程 windows netstat -ano | findstr 8889 首先找到8889端口号所对应的进程号pid 假设为1234； 关闭该进程 taskkill /F /PID 1234 这样，后台使用8889端口号就不冲突了；]]></content>
  </entry>
  <entry>
    <title><![CDATA[LiveData]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F01%2F20%2FAndroid%2FJetPack%2FLiveData%2F</url>
    <content type="text"><![CDATA[LiveData使用1、主要是使用MutableLiveData livedata主要使用在ViewModel中，数据持久化 ViewModel中声明livedata，并开放get方法view层中通过viewmodel的get方法获取livedata，并observe当前页面 livedata包裹实体bean类（Model）bean类发生变化，就使用mutable.setValue()方法通知观察者（订阅者）,观察者则会回调onchange方法 主线程调用setValue 子线程调用postValue LiveDataBus 替代EventBushttps://blog.csdn.net/AndroidO2O/article/details/86649804 https://www.jianshu.com/p/c2ce45639f57 https://blog.csdn.net/weixin_45365889/article/details/102622027]]></content>
  </entry>
  <entry>
    <title><![CDATA[BottomnavigationView]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F01%2F19%2FAndroid%2FMaterial%20Design%2FBottomnavigationView%2F</url>
    <content type="text"><![CDATA[BottomNavigationView简介：1、Material Design 设计之一 2、作用：app常见的底部tab导航栏，底部导航栏结合fragment使用，比以前手动切换fragment更加简单 使用1、res下创建navigation 布局 ，进行fragments设置：设置fragment包含的模块布局 fragment 添加属性: app:defaultNavHost=&quot;true&quot; app:navGraph=@navigation/mobile_navigation 2、menu设置：res-&gt;menu menu就是底部菜单，可以设置底部标题和图标,menu数量和fragments数量要对应 BottomNavigationView设置属性 app:menu=&quot;@menu/bottom_nav_menu&quot; 3、activity代码绑定： AppBarConfiguration appBarConfiguration = new AppBarConfiguration.Builder( R.id.navigation_home, R.id.navigation_course, R.id.navigation_training, R.id.navigation_mine) .build(); NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment); NavigationUI.setupActionBarWithNavController(this, navController);Theme为noactionbar不要设置 NavigationUI.setupWithNavController(navView, navController); 注意点：1、定位 ‘ navView.setSelectedItemId(R.id.navigation_mine); ‘ ,id是menuId 2、主题设置为NoActionbar时使用setupActionBarWithNavController系列方法会报空指针，此时直接使用 NavigationUI.setupWithNavController(navView, navController);即可 3、一些其他属性设置： app:labelVisibilityMode=&quot;labeled&quot; //设置标题不隐藏，图标和标题一直显示，避免默认的点击显示标题，不点击只显示图标 app:itemRippleColor=&quot;@android:color/transparent&quot; //关闭水波纹 总结：目前只使用了一种五个tab模式，以后根据情形继续补充]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Charles抓包工具]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F01%2F15%2F%E5%B7%A5%E5%85%B7%2FCharles%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Charles抓包工具Charles 是在 Mac 下常用的网络封包截取工具，在做 移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。 Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。 除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。 抓包工具常用的就是fiddler，iOS则是用Charles居多，本篇记录Charles工具的一些使用。 一、下载安装 Charles官网 二、使用介绍 工具栏 三、设置抓取手机的数据- 手机与电脑处在同一个网络段下 - 手机设置HTTP代理手动，代理服务器地址为电脑ip（ipconfig），端口为8888即可 四、抓取Https接口要抓取https接口，需要给手机安装ssl证书。help-&gt;SSL Proxying-&gt;Install Cahrles RootCertification on a Mobile Device or Remote Browser Android- 在Charles 工具栏里点击 Help — SSL Proxying — Save Charles Root Certificate，生成 后缀名是 .cer 的文件， 然后上传到微信里，最后点击安装! iPhone 高阶用法：拦截请求 找到url，右键Breakpoints打断点 修改请求参数,修改返回数据 打断点。 修改请求参数：找到对应的请求url设置断点，然后选择Edit Request可以编辑请求参数，修改完之后Execute即可 修改返回数据：同样是打断点，然后请求数据变点execut，然后返回数据会进入，此时点击Edit Response修改返回数据弱网环境 开启乌龟图标，网络会迟缓 其他问题1.如果在手机设置代理后charles弹出access权限框不小心拒绝（Deny）了， 在Proxy-&gt;Access Control proxy Settings上面，点add加上手机ip。然后重启charles。 更多查阅]]></content>
      <categories>
        <category>tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Module和依赖操作]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F01%2F14%2FModule%E5%92%8C%E4%BE%9D%E8%B5%96%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[git补充]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F01%2F14%2FGit%2FGit%2Fgit%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[## ## 撤销 git addgit status 查看add的文件 git reset HEAD 撤销add. git reset HEAD xxx/xxx/xxx.java 撤销add某个文件 生成ssh查看本地所获取的远程仓库信息git remote -v git 提交规范https://www.jianshu.com/p/201bd81e7dc9?utm_source=oschina-app]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpannableString]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F01%2F12%2FSpannableString%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Lifecycle]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F01%2F12%2FLifecycle-0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LifeCycle]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F01%2F11%2FLifeCycle%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LifeCycle]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F01%2F11%2FAndroid%2FJetPack%2FLifeCycle%2F</url>
    <content type="text"></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>jetpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DataBinding]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F01%2F11%2FDataBinding%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[DataBinding]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F01%2F11%2FAndroid%2FJetPack%2FDataBinding%2F</url>
    <content type="text"><![CDATA[DataBinding使用：三步：1.启用 2.布局文件中的使用方式 3、代码中的使用方式 1、启用：android{ ... dataBinding{ enabled true } ... } 2、布局文件中如何使用布局转换成layout标签，data标签下添加variable和type，variable是属性名称，type是添加的属性类，使得布局文件中可以直接引用类中的方法 3、代码中如何使用onCreate（）中取消常规的setcontentView，使用DataBindingUtils.setContentView（activity/fragment,layourResID）获取一个当前页面对象,通过此对象可以获取布局中的view并进行操作 DataBinding在libmodule中onclick报错：点击id会直接定位到view的视图位置原因是在library module中资源ID类型不是final类型的，主model中资源ID是final类型的 错误：如果有布局注释记住注释也只能放在 layout里面去 不然会报错The markup in the document following the root element must be well-formed. 错误 如果一直报错某个package找不到 。那么是资源文件除了问题 去databingding底下有个错误日志 里面找对应的文件会报错，所以这里有一点问题就是如果修改了包路径，但是layout是不会自动更改的，然后就会报错找不到对应的路径和文件 databingd 的layout在哪个module下 生成的就是哪个module的包名Didn’t find class “androidx.databinding.DataBinderMapperImpl”在项目的每个module内的build文件中加入 android { ... dataBinding { enabled = true } ... }]]></content>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F01%2F11%2F%E8%8D%89%E7%A8%BF%2F</url>
    <content type="text"><![CDATA[1、将module(模块)设置为lib 并引用 1、 选中的module，修改对应module下的build文件，讲 plugin下的id ‘com.android.application’ 修改为 ‘com.android.library’ 设置完成后 模块的图表会改变 从原点变成书 2、讲android-&gt;default下的applicationID注释掉，否则clean会报错 配置免登陆SSH邮箱不同：分别设置gitlab和github的ssh ，新建文件夹区分开即可 github SSH: https://blog.csdn.net/qq_42054174/article/details/108282789 https://blog.csdn.net/qq_42054174/article/details/108282789 https://blog.csdn.net/jiankeufo/article/details/54599473 1、检查本地有没有ssh2、生成ssh3、取出生成的ssh公钥添加到github上去 如果push发现还是要密码，则是push的方式不对，有https和ssh方式，默认是克隆下来仓库的选择方式，ssh要免密则要选择git的方式，修改方法：使用 git remote -v 查看当前fetch 和push地址 第一种方法 直接修改.git下的config 修改origin的url地址第二种方法 命令行修改 修改完成之后push可能还要绑定分支，跳转到分支绑定远程操作 蓝鲸项目android规划基础类库：commonLib kotlin@{activity::onClick}xx.Class TwoActivity::class.java 类和对象：构造方法 编译报错：Primary constructor call expected需要次构造方法调用主构造方法多构造方法： MVVMview：activity中只做界面相关的初始化和刷新 view持有viewmodel引用 ，viewmodel不持有activity引用 ViewModel 中 使用lifecycle 监听生命周期并做处理 viewmodel 可共用与activity fragment 数据库、网络请求，数据模型层放在model层 viewmodel不直接进行数据的读取 只做数据的提取回调layout重的数据对象 比如personbean 不能放在activity中，activity中只放view 所以应该放在viewmodel里面 界面刷新 用databingding 事件通知 用 livedata //要区分好层次依赖，比如这里 base要基于commonlib和commonwidget至上(需要工具类和loading)，所有只要base依赖common，app依赖bse即可 Lifecycle最佳实践尽可能保持UI控制器（Activity和Fragment）的简洁。它们不应该去获取数据，而是使用ViewModel 来做这个工作，然后观察LiveData 把变化反应给view。 尝试写数据驱动的UI，UI controller的职责是在数据改变的时候更新view，或者把用户的操作通知给ViewModel。 把数据逻辑放在ViewModel 类中。ViewModel的角色是UI控制器与app其余部分的桥梁。不过要注意，ViewModel的职责并不是获取数据（比如，从网络）。相反 ViewModel应该调用合适的控件去做这件事情，然后把结果提供给UI控制器。 使用 Data Binding来让view和UI控制器之间的接口保持干净。这可以让你的view更加声明式同时最小化Activity和Fragment中的代码。如果你更喜欢用Java代码做这件事情，使用 Butter Knife来避免繁琐的代码。 如果你的UI非常复杂，考虑创建一个Presenter类来处理UI的变动。通常这会有点多余，但可能会让UI的测试更加简单。 绝对不要在 ViewModel中引用View 或者 Activity 的context。如果ViewModel活的比Activity更长，Activity可能会泄漏，无法正常回收。 1、view层：&lt;界面变化和操作传递&gt;databinding ，activity和fragment，持有viewModel引用（在布局文件中），只做界面上的变化，数据变化通过databindding和livedata更新 2、ViewModel： &lt;负责数据逻辑&gt;模块通用的方法、请求调用 3、Model：&lt;数据的实际获取&gt;数据的获取，包括网络请求、数据库读取、 lifecycle第一步 拿到lifecycle oncreate 不要重写2参的方法 android studio 快速获取全类名 SpannableStringAndroid中的图片 bitmap drawablehttps://blog.csdn.net/qice675563721/article/details/51361098 图片压缩 图片等比压缩 图片 不失真压缩bitmap drawable 转化 质量压缩： bitmap.compress() 尺寸（像素）压缩： 从图片路径中读取图片 图片保持宽高比压缩的方法：1、看需求是限定宽还是限定高,先压缩至可以承受的最大宽/高1、计算出宽高比3、如果限定宽就以宽的标准去判断然后根据宽高比算出 对应高应该是多少 ；反之高亦然 Android获取手机屏幕密度 scroll嵌套edittext1、 edit不能滚动 重写edit ontouchevent 原因：scrollview拦截的滑动事件 2、 解决 edit滚动会自动弹回到edit底部 原因：edittex自动获取焦点 导致会定位到edit位置 网上的方法设置都不可以，我是插入了图片 1、首先解决自动获取焦点问题 那就让edittext 无法自动获取焦点 只有通过点击才能获取到焦点 2、同事 获取到焦点 要在move事件里面移走焦点 防止手松开就滑到底部 3、第三 输入法收起也会滑到底部 因为 点击获取焦点后会弹出输入框 但是焦点依旧在 edittext 上 这里要监听收入法状态 收起移走edittext的焦点 ##Timber commit提交规范化fix: 修复feat: 功能开发refactor: 重构 创建新module lib设置lib注意问题：1、依赖重复2、版本号冲突 android studio快速打开文件所对应的目录 依赖module lib 导入module库： 1、选择导入，导入成功后还要给app添加这个module的依赖 才可以成功使用库 选择导入做的操作： 修改了setting.gradle 添加了 include ‘:lib名字’ lib图标会变成图书架 添加依赖做的操作: 修改了app下的build.gradle 添加了 implemention project （path: ‘:lib名字’） 这样就可以引用lib资源了 所以直接复制文件夹 也是要完成上面两步 同理要移除一个module 一般情况下删除不了的，需要倒坐上述2步：1、移除app的依赖2、移除module3、可以delete删除项目setting 快捷键 ctrl+alt+shift+s git add 撤销##获取 屏幕宽度 和 dpi mvp、 mvvm优点：同样的接口可以共用，对数据的判空处理可以一起，免得多个地方写同一个接口会有忘记的地方造成空指针bug重复工作 ##生命周期别先调用父类的 避免出现位置错误，比如ondestroy先调用父类的 后面的组件 view都为空了 代码行数统计1、方式一： 全局搜索换行符 \nhttps://www.jianshu.com/p/8debced89342 2、方式二： 插件 statistichttps://blog.csdn.net/dreamlivemeng/article/details/67637789/ 开发文档：模块-对应模块名称（英文） ##navigationbar1、基本使用2、设置文字和图标不隐藏（不是点击才显示title）3、去掉水波纹 快速学习或者掌握一个知识或者应用：1、先看一遍介绍，了解基本功能和作用2、简单总结如何使用3、根据自己总结的使用去开始实操，实操中补充、修改自己简单总结的内容4、最后总结 全局自动控制debug版本和release版本包括日志、服务器地址、沙箱环境等等 ADT 17.0.0以上版本在Build以后，会在R.java的相同路径下生成一个叫作BuildConfig.java的文件，内容很是简单：ap 使用方法： 在appbuild下生成全局常量： buildTypes { release { buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;false&quot; ... minifyEnabled false } debug { // 不显示Log buildConfigField &quot;boolean&quot;, &quot;LOG_DEBUG&quot;, &quot;true&quot; } } 这样就生成了一个logdebug的全局常量，可以用于在application中去根据类型去选择显示还是隐藏log,然后可以根据release下和debug分别设置 组件化需要解决的问题：因为把整个应用的Application 放在最顶层的app中，所以就会遇到的问题是组件模块如何引用应用的application（组件不互相依赖的情况，比如需要使用到application中保存的user） Android多Module下的Application引用方式 基础库base/common/config中定义一个BaseApplication，里面包含自己的实例，顶层继承之后将实例赋值 ##泛型,什么是泛型 T 意义和用法T t 意义和用法https://www.cnblogs.com/east7/p/13210761.html?utm_source=tuicool 主题设置 ，颜色设置对应界面上的哪些位置colorAccent https://blog.csdn.net/jinmie0193/article/details/80723724]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kotlin]]></title>
    <url>%2FAaronYang23.github.io%2F2021%2F01%2F06%2FKotlin%2FKotlin%2F</url>
    <content type="text"><![CDATA[Kotlin学习笔记（一）基础声明类class Person(name:String){ } 抽象类：接口：属性：函数：为空设置常规语法类型判断：条件控制：循环控制：]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把Activity的view转成bitmap作为背景]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F11%2F18%2FAndroid%2FUI%2F%E6%8A%8AActivity%E7%9A%84view%E8%BD%AC%E6%88%90bitmap%E4%BD%9C%E4%B8%BA%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[把Activity的view转成Bitmap作为背景 public Bitmap getActivityBitmap(Activity activity) { // 获取windows中最顶层的view View view = activity.getWindow().getDecorView(); view.buildDrawingCache(); // 获取状态栏高度 Rect rect = new Rect(); view.getWindowVisibleDisplayFrame(rect); int statusBarHeights = rect.top; Display display = activity.getWindowManager().getDefaultDisplay(); // 获取屏幕宽和高 int widths = display.getWidth(); int heights = display.getHeight(); // 允许当前窗口保存缓存信息 view.setDrawingCacheEnabled(true); // 去掉状态栏 Bitmap bmp = Bitmap.createBitmap(view.getDrawingCache(), 0, statusBarHeights, widths, heights - statusBarHeights); // 销毁缓存信息 view.destroyDrawingCache(); return bmp; } public Bitmap getViewBitmap(View view) { view.setDrawingCacheEnabled(true); view.buildDrawingCache(); //启用DrawingCache并创建位图 Bitmap bitmap = Bitmap.createBitmap(view.getDrawingCache()); //创建一个DrawingCache的拷贝，因为DrawingCache得到的位图在禁用后会被回收 view.setDrawingCacheEnabled(false); //禁用DrawingCahce否则会影响性能 return bitmap; } 需求记录：弹出新页面，以上一个页面做虚化背景 毛玻璃：jp.wasabeef:blurry:2.1.1 //mLlParent是页面的根布局id mLlParent.buildDrawingCache(); Bitmap bitmap = mLlParent.getDrawingCache(); if (bitmap != null) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, baos); byte[] data = baos.toByteArray(); //再把bitmap转化而成的data数组传递到新页面显示 ... //新页面 byte[] bytes = getIntent().getByteArrayExtra(&quot;blurryViewBytes&quot;); blurryView = BitmapFactory.decodeByteArray(bytes, 0, bytes.length); Blurry.with(this) .color(Color.argb(177, 0, 0, 0)) .async() .from(blurryView) .into(blurryViewContainer); //blurryViewContainer是新页面的根布局 效果：]]></content>
  </entry>
  <entry>
    <title><![CDATA[日期]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F11%2F18%2FAndroid%2Futils%2F%E6%97%A5%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[日期显示自定义显示时间格式 使用SimpleDateFormat： public static String getDateForMMMTime(long time) { //注意传入的要是一个毫秒 Date d = new Date(time); SimpleDateFormat sf = new SimpleDateFormat(&quot;MMM d | yyyy&quot;,Locale.ENGLISH); return sf.format(d); } 说明-关于SimpleDateFormat支持的时间格式,中英文: * G: 公元 时代，例如AD公元 * yy: 年的后2位 * yyyy: 完整年 * MM: 月，显示为1-12 * MMM: 月，显示为英文月份简写,如 Jan * MMMM: 月，显示为英文月份全称，如 Janualy * dd: 日，2位数表示，如02 * d: 日，1-2位显示，如 2 * EEE: 简写星期几，如Sun * EEEE: 全写星期几，如Sunday * aa: 上下午，AM/PM * H: 时，24小时制，0-23 * K：时，12小时制，0-11 * m: 分，1-2位 * mm: 分，2位 * s: 秒，1-2位 * ss: 秒，2位 * S: 毫秒]]></content>
  </entry>
  <entry>
    <title><![CDATA[Drawable代码设置相关改变]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F11%2F18%2FAndroid%2FUI%2FDrawable-%E4%BB%A3%E7%A0%81%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3%E6%94%B9%E5%8F%98%2F</url>
    <content type="text"><![CDATA[Drawable代码设置相关改变代码修改shape颜色GradientDrawable gd = (GradientDrawable)textView.getBackgroud(); gd.setColor(Color.RED);]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac下adb-command not found]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F11%2F18%2FComputerSystem%2FMac%20OS%2FMac%E4%B8%8Badb-command-not-found%2F</url>
    <content type="text"><![CDATA[Mac下adb: command not found 提示adb: command not found是因为mac电脑下没有配置Android环境变量. 1.打开终端，输入: cd ~/进入用户目录; 2.输入:touch .bash_profile,如果当前没有这个文件,则会默认创建; 输入:open .bash_profile,如果是第一次创建,则默认为空白的文件; 4.输入:export ANDROID_HOME=/Users/liuyuhang/Library/Android/sdk,这里的export ANDROID_HOME=你的安卓sdk路径mac下的Android studio,点击:preferences,会出现下图页面,复制地址替换就可以了 5.输入:export PATH=${PATH}:${ANDROID_HOME}/tools 6.输入:export PATH=${PATH}:${ANDROID_HOME}/platform-tools 7.输入source .bash_profile即可使改动生效;这时再次输入adb时没有出现提示:adb: command not found就代表环境配置成功啦]]></content>
      <categories>
        <category>MAC</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[正则表达式使用和记录]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F11%2F18%2F%E9%80%9A%E7%94%A8%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%BF%E7%94%A8%E5%92%8C%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[正则表达式使用和记录判断是中文字符Pattern.compile(&quot;^[\u4e00-\u9fa5]+$&quot;).matcher(name).matches()]]></content>
  </entry>
  <entry>
    <title><![CDATA[TextView的相关操作]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F11%2F15%2FAndroid%2FUI%2Fwidget%2Fnative%2FTextView%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[TextView的相关操作一、设置部分背景色或者指定字段字体颜色 通过操作SpannableStringBuilder类实现; String只是字符串,SpannableStribg、SpanableStringBuilder可以对原来的字符串进行修饰装修，如加下划线、背景色、改变字体颜色、用图片换掉指定文字等等; SpannableStribg和SpanableStringBuilder的区别和使用可以理解String和StringBuilder的使用，主要是append()方法. //contentStr是要需要改的字符串 //设置部分背景色 SpannableStringBuilder span = new SpanableStringBuilder(contentStr); //指定长度即可 span.setSpan(new BackgroudColorSpan(Color.RED),0,5,Spannable.SPAN_EXCLESIVE_EXCLuSIVE); span.setSpan(new BackgroudColorSpan(Color.BLUE),5,contentStr.length(),Spannable.SPAN_EXCLESIVE_EXCLuSIVE); textView.setText(span); //指定字段字体颜色 SpanableString spanString = new SpanableString(contentStr); ForeGroundColorSpan span = new ForeGroundColorSpan(Color.BLUE); spanString.setSpan(span,1,5,Spannable.SPAN_EXCLESIV_INCLUSIVE); edit.set(spanString); //字体大小 SpannableString spanString = new SpannableString(contentStr); AbsoluteSizeSpan span = new AbsoluteSizeSpan(16); spanString.setSpan(span, 2, 5, Spannable.SPAN_INCLUSIVE_INCLUSIVE); editText.setText(spanString); //粗体、斜体 SpannableString spanString = new SpannableString(&quot;欢迎光临蛋蛋的博客&quot;); StyleSpan span = new StyleSpan(Typeface.BOLD_ITALIC); spanString.setSpan(span, 1, 4, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); editText.setText(spanString); //删除线 SpannableString spanString = new SpannableString(&quot;欢迎光临蛋蛋的博客&quot;); StrikethroughSpan span = new StrikethroughSpan(); spanString.setSpan(span, 2, 5, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); editText.setText(spanString); //下划线 SpannableString spanString = new SpannableString(&quot;欢迎光临蛋蛋的博客&quot;); UnderlineSpan span = new UnderlineSpan(); spanString.setSpan(span, 1, 4, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); editText.setText(spanString); //图片置换 SpannableString spanString = new SpannableString(&quot;欢迎光临蛋蛋的博客&quot;); Drawable d = getResources().getDrawable(R.drawable.ic_launcher); d.setBounds(0, 0, d.getIntrinsicWidth(), d.getIntrinsicHeight()); ImageSpan span = new ImageSpan(d, ImageSpan.ALIGN_BASELINE); spanString.setSpan(span, 2, 4, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); editText.setText(spanString); 最后一个参数的int flags：取值有如下四个，前后是指一般在edit里面继续输入是否依旧持续此效果 Spannable.SPAN_EXCLUSIVE_EXCLUSIVE：前后都不包括，即在指定范围的前面和后面插入新字符都不会应用新样式 Spannable.SPAN_EXCLUSIVE_INCLUSIVE：前面不包括，后面包括。即仅在范围字符的后面插入新字符时会应用新样式 Spannable.SPAN_INCLUSIVE_EXCLUSIVE：前面包括，后面不包括。 Spannable.SPAN_INCLUSIVE_INCLUSIVE：前后都包括。 注意：SpannableStringBuilder连续调用setSpan时参数不能用同一个span对象，否则只实现最后一次效果，要多次设置要new 多个span，如： builder.setSpan(new ForegroundColorSpan(Color.RED), 0, 1, Spannable.SPAN_INCLUSIVE_INCLUSIVE); builder.setSpan(new ForegroundColorSpan(Color.RED), 2, 3, Spannable.SPAN_INCLUSIVE_INCLUSIVE); 这样才生效 二、设置部分文字可点击，可与标记色一起使用, 通过ClickableSpanSpannableStringBuilder style = new SpannableStringBuilder(); ClickableSpan clickSpan = new ClickableSpan() { @Override public void onClick(View widget) { Toast.makeText(MainActivity.this, &quot;触发点击事件!&quot;, Toast.LENGTH_SHORT).show(); } }; style.setspan(clickSpan,3,7,Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); textView.setText(style); //同时也可以使用其他的span设置字体颜色等 //... textview中的换行无效问题 引用 在xml中，设置写入 “aaaa\nbbbb” 预览显示有效，但是后台数据返回如果是包装成了bean类，那么后天的”\n” 就失效了。经查阅得出 很简单，在程序运行的时候显示为“aaaa\nbbbb”，那么必须对TextView设置了“aaaa\\nbbbb”， 这里多了一个“\”， 对象所携带的字符串的转义已经被消除了。 通过以下的方法传递一个对象之后, 如果这个对象包含了字符串成员变量, 那么, 这个字符串所包含的转义字符将失效. 因为android已经在传递时做了手脚. intent.putExtra(EXTRA_OBJECT,People); 所以要处理也是吧\n转成\n就好了 调用方法替换\\n： String temp = myString.replace(&quot;\\n&quot;, &quot;\n&quot;); 显示temp就好了]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EditTextView]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F11%2F15%2FAndroid%2FUI%2Fwidget%2Fnative%2FEdittextView%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[EdittextView的相关操作一、增加过滤器1、有时候根据需求需要限制EditText输入的字符类型，如空格、特殊字符、表情等，这时候通过设置过滤器– InputFilter 进行过滤 InputFilter filter = new InputFilter(){ @Override public CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) { //todo 这里 source是输入的字符 dest是edit现有的字符串内容 if(source.equals(&quot; &quot;))return &quot;&quot;; else return null; } } edit.setFilters(new InputFilter[](filter)); //edit是设置一组过滤器 2、设置输入字符的限制,可以用已经有的API edit.setFilters(new InputFilter[]{new InPutFilter,LengthFilter(20){}}); 3、限制输入emoji和输入法表情 public class EmojiFilter implements InputFilter { Context context; public EmojiFilter(Context context) { this.context = context; } @Override public CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) { for (int i = start; i &lt; end; i++) { int type = Character.getType(source.charAt(i)); if (type == Character.SURROGATE || type == Character.OTHER_SYMBOL) { //不允许输入表情的提示 CommonUtils.showToast(context, App.instance().getString(R.string.no_support_moji)); return &quot;&quot;; } } return null; } } 监听键盘按键点击事件1、回车不换行回车不换行即是监听回车键的事件 edit.setOnEditActionLisener(new TextView.OnEditorActionListener() { @Override public boolean onEditorAction(TextView v, int actionId, KeyEvent event) { return (event.getKeyCode() == KeyEvent.KEYCODE_ENTER); //或者是keycode== KeyEvent.KEYCODE_ENTER，返回true消费掉即可 } }); 设置行间距修改行间距（最简单） 在xml中设置 （1）lineSpacingMultiplier属性，意思是行与行之间的距离倍数，相当于word里面的行间距，例如1.5倍行间距 android:lineSpacingMultiplier=&quot;1.5&quot; （2）lineSpacingExtra属性，直接设定行与行之间的距离，每行相距3dp android:lineSpacingExtra=&quot;3dp&quot; 通过上面的任何一种方法都可以实现行间距的调整。 禁止Edittext选中复制粘贴(填空题用到)@SuppressLint(&quot;ClickableViewAccessibility&quot;) public void disableCopyAndPaste(final EditText editText) { try { if (editText == null) { return ; } editText.setOnLongClickListener(new View.OnLongClickListener() { @Override public boolean onLongClick(View v) { return true; } }); editText.setLongClickable(false); editText.setOnTouchListener(new View.OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { if (event.getAction() == MotionEvent.ACTION_DOWN) { // setInsertionDisabled when user touches the view setInsertionDisabled(editText); } return false; } }); editText.setCustomSelectionActionModeCallback(new ActionMode.Callback() { @Override public boolean onCreateActionMode(ActionMode mode, Menu menu) { return false; } @Override public boolean onPrepareActionMode(ActionMode mode, Menu menu) { return false; } @Override public boolean onActionItemClicked(ActionMode mode, MenuItem item) { return false; } @Override public void onDestroyActionMode(ActionMode mode) { } }); } catch (Exception e) { e.printStackTrace(); } } private void setInsertionDisabled(EditText editText) { try { Field editorField = TextView.class.getDeclaredField(&quot;mEditor&quot;); editorField.setAccessible(true); Object editorObject = editorField.get(editText); // if this view supports insertion handles Class editorClass = Class.forName(&quot;android.widget.Editor&quot;); Field mInsertionControllerEnabledField = editorClass.getDeclaredField(&quot;mInsertionControllerEnabled&quot;); mInsertionControllerEnabledField.setAccessible(true); mInsertionControllerEnabledField.set(editorObject, false); // if this view supports selection handles Field mSelectionControllerEnabledField = editorClass.getDeclaredField(&quot;mSelectionControllerEnabled&quot;); mSelectionControllerEnabledField.setAccessible(true); mSelectionControllerEnabledField.set(editorObject, false); } catch (Exception e) { e.printStackTrace(); } } 然后使用 disableCopyAndPaste(editText); 即可 光标样式修改&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot; &gt; &lt;size android:width=&quot;2dip&quot; /&gt; //设置高度无用 &lt;solid android:color=&quot;@color/red&quot; /&gt; &lt;padding android:top=&quot;2sp&quot; //光标上移距离 因为光标高度是matchHeight的 android:bottom=&quot;-11sp&quot; /&gt; //光标下移动距离，要缩短即这里填辅助 &lt;/shape&gt; 然后edittext设置： android:textCursorDrawable=&quot;@drawable/xxx Edit设置行间距之后，光标会很长处理光标会默认matchHeight,如果只有单行，那么设置corsor样式即可，如果有多行那么不行，多行的和尾行的高度会不一致，这里处理方法用 LineHeightEditText github:LineHeightEditText]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动画]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F10%2F06%2F%E5%8A%A8%E7%94%BB(%E4%B8%80)%20%E8%A7%86%E5%9B%BE%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[Android动画 (一) 视图动画概述动画分类： 概述： 视图动画的缺陷： 对象的局限性：仅限于View 只改变了View的视觉效果，没有改变View的属性 动画效果单一 属性动画的特点： 作用对象：任意对象，没对象也可以 作用方式：改变对象的属性 动画效果：按需自定义。不再局限于四种基本变换 继承关系 帧动画（Frame Animation）补间动画（Tween Animation）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tint]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F09%2F20%2FAndroid%2FUI%2FTint%2F</url>
    <content type="text"><![CDATA[关于Tint tint翻译过来就是色调、染色、着色的意思。所以就是为view进行颜色变化的一个属性 效果就是为控件除了可以设置background改变颜色之外另外设置颜色的一种属性。 只针对于Android5.0+ 没有图片而空有tint属性是不会生效 主要应用在矢量图处作用更大 属性分类xml中使用： android:tint=&quot;&quot; android:backgroundTint=&quot;&quot; android:foregroundTint=&quot;&quot; android:drawableTint=&quot;&quot; （TextView用来着色附加drawable的） 对应有设置着色的模式： android:tintMode=&quot;&quot; android:backgroundTintMode=&quot;&quot; android:foregroundTintMode=&quot;&quot; android:drawableTintMode=&quot;&quot; 模式的选择： add：两层绘制叠加融合 multiply：取两层绘制的交集 screen：上下层都显示（就像是多了块tint色的玻璃） src_atop： src_in：取交集，显示上层 src_over：tint色覆盖住图片，都显示 优点1、可以轻松改变图片的颜色2、项目中有重复的图片只是颜色不同的可以不用切很多图，开发者自己填充颜色，省去了多余图片占据的空间，尤其是线形矢量图的情况下3、设置不同的theme，tint引用主题颜色4、固定控件增加颜色闪烁效果（项目中的需求） 使用xml中设置tint如上使用代码中设置tint： 第一种不去区分版本：(不完整，具体看下面的参考) ImageView image = new ImageView(context); Drawable up = ContextCompat.getDrawable(context,R.drawable.ic_sort_up); Drawable drawableUp= DrawableCompat.wrap(up); DrawableCompat.setTint(drawableUp, ContextCompat.getColor(context,R.color.theme)); image.setImageDrawable(drawableUp); 第二种区分版本（只能在API21以上使用） if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) { ImageView image = new ImageView(context); image.setImageResource(R.drawable.ic_sort_down); image.setImageTintList(ColorStateList.valueOf(ContextCompat.getColor(context,R.color.theme))); } PorterDuffProterDuff是两个人名的组合: Tomas Proter和 Tom Duff. 他们是最早在SIGGRAPH上提出图形混合概念的大神级人物. 利用ProterBuff.Mode我们可以完成任意2D图像测操作， 比如涂鸦画板应用中的橡皮擦效果 效果展示: PorterDuff.Mode为枚举类,一共有16个枚举值: 1.PorterDuff.Mode.CLEAR 所绘制不会提交到画布上。 2.PorterDuff.Mode.SRC 显示上层绘制图片 3.PorterDuff.Mode.DST 显示下层绘制图片 4.PorterDuff.Mode.SRC_OVER 正常绘制显示，上下层绘制叠盖。 5.PorterDuff.Mode.DST_OVER 上下层都显示。下层居上显示。 6.PorterDuff.Mode.SRC_IN 取两层绘制交集。显示上层。 7.PorterDuff.Mode.DST_IN 取两层绘制交集。显示下层。 8.PorterDuff.Mode.SRC_OUT 取上层绘制非交集部分。 9.PorterDuff.Mode.DST_OUT 取下层绘制非交集部分。 10.PorterDuff.Mode.SRC_ATOP 取下层非交集部分与上层交集部分 11.PorterDuff.Mode.DST_ATOP 取上层非交集部分与下层交集部分 12.PorterDuff.Mode.XOR 异或：去除两图层交集部分 13.PorterDuff.Mode.DARKEN 取两图层全部区域，交集部分颜色加深 14.PorterDuff.Mode.LIGHTEN 取两图层全部，点亮交集部分颜色 15.PorterDuff.Mode.MULTIPLY 取两图层交集部分叠加后颜色 16.PorterDuff.Mode.SCREEN 取两图层全部区域，交集部分变为透明色 还有另外两个 17.PorterDuff.Mode.ADD 18.PorterDuff.Mode.OVERLAY 附上自己写的闪烁的效果：参考: 在代码中实现android:tint效果]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我买过的书]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F09%2F20%2F%E6%88%91%E4%B9%B0%E8%BF%87%E7%9A%84%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[技术类Android源码设计模式解析与实战 呼啸山庄 穷爸爸富爸爸]]></content>
  </entry>
  <entry>
    <title><![CDATA[mvp]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F08%2F16%2Fmvp%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[警告和解决收录]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F08%2F14%2F%E8%AD%A6%E5%91%8A%E5%92%8C%E8%A7%A3%E5%86%B3%E6%94%B6%E5%BD%95%2F</url>
    <content type="text"><![CDATA[首先来看看看AndroidStudio对这个问题的详细介绍： 导致这样的问题是你的menifest文件中的application 中android:allowBackup=”true”; allowBackup安全风险描述:Android API Level 8及其以上Android系统提供了为应用程序数据的备份和恢复功能，此功能的开关决定于该应用程序中AndroidManif est.xml文件中的allowBackup属性值[1] ，其属性值默认是True。当allowBackup标志为true时，用户即可通过adb backup和adb restore来进行对应用数据的备份和恢复，这可能会带来一定的安全风险。 Android属性allowBackup安全风险源于adb backup容许任何一个能够打开USB 调试开关的人从Android手机中复制应用数据到外 设，一旦应用数据被备份之后，所有应用数据都可被用户读取；adb restore容许用户指定一个恢复的数据来源（即备份的应用数据）来恢复应用程序数据的创建。因此，当一个应用数据被备份之后，用户即可在其他Android手机或模拟器上安装同一个应用，以及通过恢复该备份的应用数据到该设备上，在该设备上打开该应用即可恢复到被备份的应用程序的状态。 尤其是通讯录应用，一旦应用程序支持备份和恢复功能，攻击者即可通过adb backup和adb restore进行恢复新安装的同一个应用来查看 聊天记录等信息；对于支付金融类应用，攻击者可通过此来进行恶意支付、盗取存款等；因此为了安全起见，开发者务必将allowBackup标志值设置为false来关闭应用程序的备份和恢复功能，以免造成信息泄露和财产损失。 allowBackup风险修复建议 阿里聚安全建议将allowBackup属性值显示设置为false：版权声明：本文为CSDN博主「Arman_」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_17338093/article/details/55506543]]></content>
  </entry>
  <entry>
    <title><![CDATA[strings.xml的细节使用]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F08%2F09%2FAndroid%2FUI%2Fwidget%2Fnative%2Fstrings-xml%E7%9A%84%E7%BB%86%E8%8A%82%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[strings.xml的使用总结优点&amp;作用 一、国际化 二、可重复使用，减少应用体积 用法 代码中引用strings里的字符串API：context.getResources.getString(R.String.xxxx) 在有activity的情况下，直接调用getResources.getString(R.String.xxxx) 没有实例ctivity的时候，用application的实例去调用getResources.getString(R.String.xxxx)方法 tip：后面的更新添加的简易方法，可以直接调用context.getString(R.String.xxxx)方法或者context.getText(R.String.xxxx) 定义String数组（arras.xml）&lt;string-array name=&quot;del_dur_time&quot;&gt; &lt;item&gt;从不&lt;/item&gt; &lt;item&gt;30天&lt;/item&gt; &lt;item&gt;7天&lt;/item&gt; &lt;item&gt;24小时&lt;/item&gt; &lt;item&gt;1小时&lt;/item&gt; &lt;/string-array&gt; StringArray可以直接定义在strings文件里，也可以定义在新建arrays.xml里 item里面的值也可以是引用strings： @string/xxx java中调用： ----getResources().getStringArray(R.string.sports); 格式化占位符，%s变量文本格式，动态设置string值 % 后面是占位符的位置，从1开始; $ 后面是填充数据的类型 $d：表示整数型； $f ：表示浮点型，其中f前面的.2表示小数的位数 $s：表示字符串 例子： 1.在strings.xml中定义 我叫%1$s，我%2$s贼溜，我段位王者%3$d,不信可以%4$s一起玩! 2.在类中调用 String s = String.format(mActivity.getResources().getString(R.string.tips),&quot;张三“，”吃鸡“，1,”晚 上“)) 或者 getResource.getString（mActivity.getResources().getString(R.string.tips),&quot;张三“，”吃鸡“，1,”晚 上“)） 打省略号如果直接在项目中用 。。。做省略号的话，会有警告：Replace &quot;...&quot; with ellipsis character (…, &amp;#8230;)原意就是用unicode去显示这个省略号只有一个字符，三个点是三个字符，，可以直接复制这个字符去代替省略号： …也可以按照提示使用 &amp;#8230; 不过有试过后面这个是中间省略 ### 前面加空格android中的空格编码 string.xml前后加空格的技巧 &lt;string name=&quot;space&quot;&gt;&amp;#160;&amp;#160;&amp;#160;&amp;#160;我来看空格&lt;/string&gt; &amp;#160;这个就代表着空格 特殊符号&amp;转义字符XML转义字符 以下为XML标志符的数字和字符串转义符 &quot; (&amp;#34; 或 &amp;quot;) 或者加转义字符 \ &apos; (&amp;#39; 或 &amp;apos;) &amp; (&amp;#38; 或 &amp;amp;) lt(&lt;) (&amp;#60; 或 &amp;lt;) gt(&gt;) (&amp;#62; 或 &amp;gt;) \n 换行 单引号报错： 遇到如下错误的时候说明你需要在单引号签名加转义字符 \:将定义的字符串中的单引号) , 修改为 \&#39; 即可 如： &lt;string name=&quot;hint_write_taskcontent&quot;&gt;It&apos;s my name&lt;/string&gt; 会报错 改成 &lt;string name=&quot;hint_write_taskcontent&quot;&gt;It\&apos;s my name&lt;/string&gt; tip：有特殊字符的也可以直接用双引号把整个string值包裹起来，如： &lt;string name=&quot;hint_write_taskcontent&quot;&gt;&quot;It&apos;s my name&quot;&lt;/string&gt; 定义字体的颜色TextView可以通过设置textColor属性来设置，字体的颜色。但是TextView设置textColor属性时，设置的是全部显示内容字体的颜色。假如“Android的国际化”，“Android”是红色，“国际化”是蓝色，该怎么设置呢？是不是需要用TextView拼接。我们可以这样做： &lt;string name=&quot;worlds&quot;&gt;&lt;Data&gt;&lt;![CDATA[&lt;font color=&quot;#ff0000&quot;&gt;Android&lt;/font&gt;的&lt;font color=&quot;#0000ff&quot;&gt;国际化&lt;/font&gt;]]&gt;&lt;/Data&gt;&lt;/string&gt; String worlds = getResources().getString(R.string.worlds); Spanned ws = Html.fromHtml(worlds); 总结其实这些都是html语言，而TextView是可以显示Html处理的文字的，所以会html语言则这里使用的功能会更多]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>组件&amp;基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android 代码规范lint]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F08%2F08%2FMine%20Todo%2Fandroid-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83lint%2F</url>
    <content type="text"><![CDATA[Android Lint 阿里代码规范 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD hexo 新建文本 头标题设置如何 带有 catrgories 5287d0c0ee5bc5df775d19ad4befd2583ff0fa34 kotlin环境配置： ext.kotlin_version = ‘1.3.72’classpath “org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version” implementation &quot;androidx.core:core-ktx:+&quot; implementation &quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version&quot;]]></content>
  </entry>
  <entry>
    <title><![CDATA[mac快捷键]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F08%2F08%2FComputerSystem%2FMac%20OS%2Fmac%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[MacOs快捷键和相关功能F3 显示桌面 shift + command + . 当前目录输入查看隐藏文件 command + c/v 复制/粘贴 option + command + v 剪切，先执行文件复制 commmand + m 最小化当前窗口 command + w 关闭当前窗口 command + space spotlight搜索 option + command + esc 打开任务管理器,可强制退出应用 control + command + f 打开/关闭应用全屏 command + 退格键 删除文件 AS里的快捷键shift + command + f 全局搜索 option + command + ⬅️/➡️ 回到上次编辑位置 command + ， 打开设置 ，插件安装位置 option + command + L 格式化代码 shift + f6 修改名称 command + n 打开控件插入 option + enter 补全、导包和提示 鼠标&amp;键盘&amp;键位1、鼠标滚轮方向修改设置 -&gt; 鼠标 -&gt; 勾选: 滚动方向：自然 为mac方式，不勾选为windows方式 2、键盘键位修改设置 -&gt; 键盘 -&gt; 修饰键 修改想替换的 3、连续删除和连按设置 -&gt; 键盘 -&gt; 设置按键 重复最快，延迟最短 4、关闭右上角的command、option、shift弹窗设置 -&gt; 辅助功能 -&gt; 不勾选粘滞键 自定义鼠标右键菜单command + space 启用spotlight搜索 Automator 将终端添加到右键菜单用于文件夹下，如git bash 右键直接新建txt右键可以选择位置并在当期位置打开终端 不显示 control option command 点击右上角弹出开关按钮 请关闭粘滞键（设置-辅助功能） 指定文件夹打开终端进入‘系统偏好设置’-&gt;’键盘’-&gt;’快捷方式’-&gt;‘服务’勾选 新建位于文件夹位置的终端标签 ， 新建位于文件夹位置的终端窗口。 其他问题1、当Mac OS通过 npm 安装 React Native 报错，警告文字为：checkPermissions Missing write access to /usr/local/lib/node_modules 报错原因： npm 的安装权限不足 解决办法：在安装命令前加上 sudo，根据提示输入密码即可 2、低版本的macOS系统验证双重验证：在AppleID的密码后面加上双重验证的验证码，双重验证只绑定一个基础获取验证码的设备，其他地方要登录AppleID账户需要此设备进行验证，保证即使AppleID账户泄露别人也无法登录，一旦开启无法取消，]]></content>
  </entry>
  <entry>
    <title><![CDATA[安卓项目架构]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F08%2F08%2F%E5%AE%89%E5%8D%93%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[分层构建你的依赖库https://www.jianshu.com/p/06d417b554efhttps://www.jianshu.com/p/14727ea2f60chttps://www.jianshu.com/p/49566d16bafe 《阿里巴巴编码规范（java》https://www.jianshu.com/p/a3001787b7d3]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android国际化]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F08%2F07%2FAndroid%2F%E4%B8%8A%E7%BA%BF%2F%E5%9B%BD%E9%99%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[国际化处理流程1、先对项目进行无用资源清理，省去做无用的字符国际化 2、检查代码中硬编码出现汉字的地方 3、将硬编码采用字符串引用strings。字符串分包，对于架构分层处理的依赖，要分别去修改对应下的values文件夹 4、检查图片中有语言部分的提示的 换成对应的英文部分 5、添加项目对于语言切换的管理工具 6、对转换成英文字符比较长的进行效果查看，进行适配检查和处理 7、第三方的控件如果是jar包和依赖的国际化、后台字符提示的国际化（未完成） 去除无用资源Analyze-&gt; Run Inspection by name -&gt; 输入unused resources -&gt; Whole lint对strings检测除无效的删掉编译会报错的时候，查看下是否是因为无效的xml或者代码引用了这个资源导致的，不是lint检测的不对 检测代码中的HardCode1、使用Android Lint查找硬编码 Analyze-&gt;Inspect code 2、使用全局查找查找可以使用正则表达式，正则表达式如下 ^((?!(\*|//)).)+[\u4e00-\u9fa5] 然后可以选择查看java的，也可以选择查看xml的，然后逐个修改,建议先用Android Lint 再用全局查找去寻找项目中出现硬编码的地方, strings和图片做处理strings操作 stings.xml 字段添加对应文件夹 values-en 图片添加对应的 mipmap-en-mdpi , mipmap-en-xxhdpi … 如果翻译不来或者觉得奇怪，找一个相似类app做过国际化的反编译res获得其国际化翻译 工具类LanguageUtils工具主要功能:对于要应用内切换语言，包含自动、其他语言选择 Locale是Java中对于语言管理的一个类,想要管理首先要获得Locale对象 API：1、获取app应用内的的语言类型 //7.0以前： context.getResource().getConfiguration().locale; //7.0之后,上面的获取方法提示过时(deprecated) //系统语言支持多个，可设置一组，不再像之前是单选一种语言。getLocale()变成了getLocales(),返回的是一个LocalList对象，包含1个以上Locale，用户可以进行增删和排序，返回的语言顺序不一定就是用户定义的排序顺序. LocaleList localList = context.getResource().getConfiguration().getLocales(); Locale currentlLocale = localeLitt.get(0); 2、获取当前系统的语言类型 Locale.getDefult(); 3、设置app的语言 //7.0之前,null可以使用原来的resources.getDisplayMetrics() config.locale = yourLocale; context.getResource().updateConfigration(config,null) //7.0之后，Android API 25在中已经不推荐使用updateConfigration,标记过时 config.setLocale(your locale); context.createConfigurationContext(configuration) //语言设置完之后，还要对app进行刷新,调用 activity.recreate(); 4、兼容总结 7.0 context.getResource().getConfigutation().locale 过时 context.get().createConfigurationContext(configuration) 过时 8.0 在切换语言获取Resource对象时候，8.0以下 activity和application都可以，8.0之后只能用activity，用application会报空指针 参考:硬编码的排查 Android 7.0以上版本，如何实现应用内语言切换 Android多语言以及APP内切换语言的实现]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>国际化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 分支操作]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F08%2F07%2FGit%2FGit%2Fgit-%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[git强大的也是分支。鄙人也遇到分支的相关问题，所以还是要重新总结下分支的相关用法 git pull 与 push 都只对当前分支进行操作 1、获取远程服务器的某个分支1、git clone 项目 执行 查看本地和远程所有分支git branch -al 获取&amp;创建新分支 开分支有2种方式 一种是获取远程服务器开的 一种是本地开，然后推到服务器上去 1、服务器创建，本地获取(获取远程分支)git branch -r //查看远程所有分支 git checkout -b feature-branch origin/feature-branch //检出远程的feature-branch分支到本地 ps:如果远程新建分支 本地调用-r没有看到，则用下面两步更新下（也有可能是在列表下面 用下箭头查看所有先） git remote # 列出所有远程主机 git remote update origin --prune # 更新远程主机origin 整理分支 2、本地创建推送到服务器1、本地创建并切换到新建的分支 git brach 分支名 2、推送到服务器 git push origin 本地分支名:远程分支名 //冒号分隔 3、本地分支关联远程分支 git branch –set-upstream-to=origin/远程分支名 本地分支名 如果不做这一步，那么在进行本地分支pull操作的时候会报错误： 新建本地分支后将本地分支推送到远程库, 使用git pull 或者 git push 的时候报错 gitThere is no tracking information for the current branch. Please specify which branch you want to merge with. See git-pull(1) for details git pull &lt;remote&gt; &lt;branch&gt; If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/&lt;branch&gt; merged0.9.6 -&gt; 23步骤可以合一语法处理 git push --set-upstream origin 分支名 4、检查本地分支是否都关联上并且可以使用pull、push git branch -vv 删除分支注意：不能删除当钱checkout的分支,首先要切换到其他分支 删除本地分支 git branch -d 分支名 未合并的分支强制删除: git branch -D 分支名 删除远程分支 git push origin --delete 分支名 分支合并 首先理解下分支的合并，不是2个分支合并了之后，2个分支的内容就一样了，主要是看合并到哪个分支，合并过的分支有两个分支所有的内容。另外一个分支保持不变 分支合并的方法有2种： merge 和 rebase 首先merge（合并） 和 rebase（变基） 它们最终的结果是一样的，但 rebase能产生一个更为整洁的提交历史 分支合并的情况有2种 快进合并 一种是单分支合并到主分支 基于共同祖先的三方合并 一种是多个分支先合并再合并到主分支 Git的核心概念 记住开发过程中哪个是主要项目历史分支，谁合并谁很重要，合并是merge、rebase之后的分支参数 切换到某个分支，调用此分支的merge语句 是将要合并的改动内容增加到此分支里面来，比如我想让，master的内容不变，但是他改bug的一个版本要更新到我b2分支上，则就切换到b2进行merge语句 注意git是指针移动，，所以进行合并操作 比如是master想合并之后的分支 则是要切要master上面 git rebase –abort //终止rebase操作 https://www.cnblogs.com/pixy/p/4496232.html 合并原则 开发中如果在master上开分支做功能的时候，到了功能做完要合并的时候，应该是先在功能分支上合并master的代码，然后解决冲突进行功能测试的测试，测试通过了之后再在master上面合并功能分支的代码。这样可以保证万一出现问题或者意外的冲突master的代码不会混乱，而且从第二次合并是不需要解决冲突的 Git分支管理策略 git rebase 使用]]></content>
  </entry>
  <entry>
    <title><![CDATA[macOS开发者使用]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F08%2F06%2FComputerSystem%2FMac%20OS%2FmacOS%E5%BC%80%E5%8F%91%E8%80%85%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[# mac快捷键：https://www.jianshu.com/p/7db66819610b MacDown 分支的合并处理 git:获取远程分支 :在本地创建远程分支 并切换到该分支 git checkout -b dev(本地分支名称) origin/dev(远程分支) 切换到此分支之后则可以pull https://www.v2ex.com/t/314942 分支推送到远程 https://blog.csdn.net/private66/article/details/80508193 分支如何有效使用 360doc.com/content/15/0922/14/21631240_500707688.shtml typora macdown]]></content>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F07%2F26%2F%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[内存溢出程序使用的内存超过了允许的最大内存，使得程序在申请内存时，没有足够的空间供其使用 可能会造成内存溢出的原因：内存中加载的数据量过于庞大2、不能回收的对象冗余3.代码中存在循环中过多重复的对象实体4、启动参数内存值设定的过小5。第三方软件的bug 需要了解：安卓程序是如何在手机中运行，包括jvm，内存分析 解决方案：修改jvm启动参数，直接增加内存2 检查代码，找出可能发生内存溢出的位置3，处理内存泄漏 内存泄漏该释放的内存空间没有得到释放，无法回收 引起内存泄漏的场景：资源对象没有关闭或者释放，比如cursor，比如bitmap，有些置空不够还需要调用recycle方法对象被生命周期长的对象引用 如何观察：android中我们执行一段代码进入了一个新的Activity，这时候我们的内存使用肯定比在前一个页面大，而在界面finish返回后，如果内存没有回落，那么很有可能就是出现了内存泄漏。 内存抖动 同一个activity有多个实例，然后有些实例就没有被回收 为什么要避免频繁GC，因为Gc一旦运行会暂停所有线程等待gc运行完毕， 如何检测; 引用分类： 强引用 软引用 弱引用 虚引用 泄漏方式处理：找与该静态变量生命周期差不多的替代对象和将强引用方式改成弱（软）引用 将内部类变成静态内部类 LeakCanary针对Activity/Fragment的内存泄漏检测非常好用 Android monitor https://blog.csdn.net/u012350993/article/details/79363885 https://blog.csdn.net/CrazyMo_/article/details/80214205 https://blog.csdn.net/songzi1228/article/details/84235901 https://www.cnblogs.com/dmblog001/p/5795660.html https://www.jianshu.com/p/aaee2d27068e https://www.cnblogs.com/huilixieqi/p/9707680.html https://www.cnblogs.com/renhui/p/11075548.html https://www.jianshu.com/p/60efad38c5d6?utm_source=oschina-app https://blog.csdn.net/huang_rong12/article/details/51628264]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android性能优化]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F07%2F25%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[平时开发中设计到哪些性能优化，你是从哪些地方来优化，你是通过什么工具来分析的？ 笼统的说：就是让App反应更快，使用更稳，流量、电量更省，apk更小。 具体的说：省电优化、内存优化、网络优化、图片优化、UI优化。 更快：使用时避免出现卡顿，响应速度快，减少用户等待的时间，满足用户期望。 UI优化： 分析工具：Systrace (1)减少层级，合理使用 RelativeLayout 和 LinerLayout，合理使用Merge，Include。 (2)提高显示速度，使用 ViewStub，它是一个看不见的、不占布局位置、占用资源非常小的视图对象。 (3)布局复用，可以通过标签来提高复用。 (4)尽可能少用wrap_content，wrap_content 会增加布局 measure 时计算成本，在已知宽高为固定值时，不用wrap_content 。 (5)删除控件中无用的属性。 更稳：减低 Crash 率和 ANR 率，不要在用户使用过程中崩溃和无响应。 (1)增加相应的判断，以及异常处理。 (2)避免在主线程做耗时操作。 更省：节省流量和耗电，节约内存，减少用户使用成本，避免使用时导致手机发烫。 耗电分析工具：Battery Historian (1)避免浮点运算。 (2)根据客户端图片的大小要求叫UI做相应大小的图提供给服务器，避免过大消耗更多流量和电量。 (3)不用的广播，服务记得及时关闭。 内存分析工具：Memory Monitor (1)对象引用:强引用、软引用、弱引用、虚引用四种引用类型，根据业务需求合理使用不同，选择不同的引用类型。 (2)减少不必要的内存开销:注意自动装箱，增加内存复用，比如有效利用系统自带的资源、视图复用、对象池、Bitmap对象的复用。 (3)使用最优的数据类型:比如针对数据类容器结构，可以使用ArrayMap数据结构，避免使用枚举类型，使用缓存Lrucache等。 (4)图片内存优化:点9图减少图片大小以及可以设置位图规格，根据采样因子做压缩，用一些图片缓存方式对图片进行管理等。 更小：安装包小可以降低用户的安装成本。 (1)做混淆优化代码。 (2)删除无用的代码及图片相应的本地库。 (3)Lint优化。 (4)zip压缩。作者：IBM_Forever来源：CSDN原文：https://blog.csdn.net/qq_17678217/article/details/87177493版权声明：本文为博主原创文章，转载请附上博文链接！]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo更多功能使用]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F07%2F09%2FGit%2FHexoBlog%2Fhexo%E6%9B%B4%E5%A4%9A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Hexo 更多功能使用主题设置博客主题设置参阅1 博客主题设置参阅2 https://blog.csdn.net/fanxiaobin577328725/article/details/79209975 http://theme-next.iissnan.com/theme-settings.html https://www.jianshu.com/p/3a05351a37dc 8、博客个性化设置 官方Theme：Hexo Theme 个人博客收藏: archer cube yilia varaint 可能的错误： WARN No layout: index.html 运行git clone 指令获得主题后（假设是NEXT主题）， 在theme主题下保存文件夹的名称为：hexo-theme-next-0.4.0 那么如果在config里设置的是next，就会出现这样的WARN，http://localhost:4000/显示的是空白。 只要把theme下的文件夹名称改为next就显示正常了。 同样是空白页面的记得查看下主题下的名字和文件夹层次是否对应 草稿箱 想创建不显示的博客文件，比如记录一些信息 把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。 hexo draft new &quot;草稿箱&quot; //会在source文件夹下的draft文件夹生成文件，文件不被显示在页面上，链接也访问不到 让草稿箱可见1.将文件移出draft文件夹 2.其余操作 //如果你希望强行预览草稿，更改配置文件： render_drafts: true //或者，如下方式启动server： $ hexo server --drafts //把草稿变成文章，或者页面： $ hexo publish [layout] &lt;filename&gt; hexo设置Hexo主题下载 添加其他页面（关于，标签，分类页面）代码块风格设计修改主题宽度找到对应主题对应风格的layout文件夹修改https://blog.csdn.net/csdnSR/article/details/78300820 给 hexo next 加上背景图片，只需要在 themes\next\source\css_custom\custom.styl 文件中添加几行代码： @media screen and (min-width:1200px) { body { background-image:url(/images/background.jpg); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; } #footer a { color:#eee; } } 给新创建的博客管理 主题、文章源文件备份 主题和文章源文件选择托管到github上面。连带整个hexo目录文件夹一起 图片资源存放图片总共2种方式存放：网络： 1、找第三方的图片存储，如七牛云 2、第一种方法会麻烦一点，要记多个账号，目前选择是在github上建立仓库存放图片，然后直接复制图片地址。 注意：建仓库不能为私有的，私有仓库图片会加载不出来 本地：本地的话之前是在source文件夹下建立了一个images目录 ，。这里技术待跟进，看能否设定path为上层路径的image文件夹下的资源而不是绝对路径本地的话一旦路径更改或丢失都会造成显示不出，不灵活也不方便分享，所以还是建议以网络图片的形式]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo错误记录]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F07%2F09%2FGit%2FHexoBlog%2Fhexo%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[Hexo错误记录用不了hexo指令只能运行hexo v指令，其余均为提示 Useage:hexo，注意hexo指令是要运行在git bash 中，不是cmd中。 hexo g错误收录 YAMLException: end of the stream or a document separator is expected at line x, column y: 缺少分隔符，一般都是因为缺少空格 解决方案:出现这种情况，一般都是缺少空格，在:冒号之后要有空格！检查x行y列附近的冒号，其之后是否跟了空格。 ValidationError: ‘null’ is not a string! 一般都是因为文章无内容，可能是因为在这篇博客文章中，有某些属性没有填写，比如author属性，tag属性，categories属性等，导致该属性是空的，即null，所以报错。 解决方案既然是属性缺失，仔细找找把为空的那个属性给补上 generate的时候是没问题的，但是网页预览的时候，发现引用块有问题，原本引用块下方的内容跑到引用块里边去了！ 解决方案 引用块都是由一对三个所包起来的，如果在最后一个点之后有空格，界面会错乱，所以，把这个多余的空格去掉吧。 hexo-d运行失败1、因为我设置的是 blogfiles-&gt;hexo注意我是把blogfiles是自己的仓库保存所有源文件，这里操作hexo指令是无效的，要操作hexo的相关操作要在hexo文件夹下，要部署博客更新则要看 .deploy_git 的位置在哪就在哪操作 2、注意看配置文件下deploy的仓库设置是否正确，如果一直密码错误要看看仓库地址是否正确 hexo new “” 新文章的时候 中文名称的文件名会显示乱码这里是跟电脑设置有关，要修改当前系统的语言环境。 以win10为例，搜索 -&gt; 控制面板 -&gt; 更改日期、时间或数字格式（类别）-&gt; 管理 -&gt;更改系统区域设置-&gt;选择中文简体，勾上使用Unicode t提供全球语言支持 The “mode“ argument must be integer. Received an instance of Object问题原因：hexo和node版本不兼容，hexo和node有对应的版本兼容关系，一般是因为node版本过高 处理：降低node版本 1.卸载干净电脑的node.js 2.安装node管理工具nvm — 官方下载nvm-setup.zip 3.通过nvm操作安装指定版本 注意: 为了避免安装失败，最好在安装指定node.js之前先去设置从淘宝的镜像路径安装 4.安装完成后通过use命令和-v命令查看是否启用和安装，后续就是hexo的相关处理了 注: 如果hexo仓库已经init过了的话只要安装好hexo就可以用了 参考： nvm 配置淘宝镜像 nvm管理node.js]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的依赖库]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F06%2F09%2F%E6%88%91%E7%9A%84%E4%BE%9D%E8%B5%96%E5%BA%93%2F</url>
    <content type="text"><![CDATA[记录自己的依赖库 动态权限申请工具 项目曾使用过的依赖库//Gif implementation &apos;pl.droidsonroids.gif:android-gif-drawable:1.2.1&apos; //仿ios的tip提示语样式SVProgressHUD implementation &apos;com.bigkoo:svprogresshud:1.0.6&apos; //富文本jsoup implementation &apos;org.jsoup:jsoup:1.11.2&apos; //自适应文字textview implementation &apos;me.grantland:autofittextview:0.2.+&apos; //toggle button implementation &apos;com.zcw:togglebutton-library:1.0.0&apos;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>依赖库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库升级]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F04%2F16%2FAndroid%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%87%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[数据库升级##新增加的表字段要打好注释，比如某个字段是相对于xx版本新增的。这也才能分清哪些字段新增 哪些表有更新 ，做好一个功能模块就要更新新增加的表也要打好某某版本新加的 数据库版本升级分析如何做好数据库版本升级1、罗列出升级后的数据库所有的表的相关信息2、查看上一版本的数据库所有的表的相关信息，列出需要更新的表，确定更新的内容,保证数据库无差错3、进行合理的版本判断进行升级ps:开发中，如果有添加新表就应该及时加上或者做个数据库备注，避免遗忘 开发习惯：启用一个公共的类，保存项目中新建的所有数据库表，方便以后定位，greenDao则直接将表的bean对象至于一个包中 greenDao数据库升级更新/版本文档1、版本号、数据库版本号、上传市场时间1、写出这个版本数据库的表结构2、对比上一版本新增的功能3、新增的功能接口4、新启用的shareprefreces保存变量 App更新要做的1、备份一份源码,（其实可利用git） 清空原表数据 再初始化]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 开发规范]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F03%2F20%2FAndroid%2F%E8%A7%84%E8%8C%83%E5%92%8C%E6%9B%B4%E5%A4%9A%E4%BD%BF%E7%94%A8%2F%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[Android 开发规范图标规范logo尺寸l:3636m:4848h:7272xh:9696xxh:128128 or 144 144xxxh:192*192 vivo市场要求的高清logo尺寸：h:192192xh:256256xxh:384384xxxh:512512 注意：logo如果是圆角,圆角度度数不要太大，因为有的手机系统统一是圆角，度数如果超过那些手机自己定义的圆角度数会显得和其他app不一样，所以要尽量小一点。 https://www.jianshu.com/p/45c1675bec69 https://www.cnblogs.com/ycxyyzw/p/4103284.html Android应用版本命名###versioncode 此值必须是递增变大的整数，为了比较是否需要更新。常见的有两种命名方式： 1、时间命名法，直接采用发布当前的日期，比如versioncode:20170527 2、版本控制提交号，此方式便于回滚到对应版本的源代码。 versionname 版本号的形式是major.minor.maintenance.build major是主版本号，一般在软件有重大升级时增长,功能模块有大的变动，比如增加多个模块或者整体架构发生变化。 minor是次版本号，一般在软件有新功能时增长,和主版本相对而言，次版本号的升级对应的只是局部的变动。但该局部的变动造成了程序和以前版本不能兼容，或者对该程序以前的协作关系产生了破坏，或者是功能上有大的改进或增强。 maintenance是维护版本，一般在软件有主要的问题修复后增长,局部的变动，主要是局部函数的功能改进，或者bug的修正，或者功能的扩充 build构建版本（测试版本一般会用到） 此字段的版本名是用户安装可以看到的，常见的命名方式如下： 正式版本：major.minor.maintenance—-1.0.0 测试版本：major.minor.maintenance.build—-1.0.0.5 Git使用资源命名 资源id：ac/fragment缩写+view类型+view作用,如：settingTVModifyName,因为butterknife会把下划线的id命名在代码文件中会转为驼峰，所以为了一致性建议不用下划线使用驼峰命名法。觉得太长可以把ac/fragment缩写去掉。 drawable文件： 数据库https://blog.csdn.net/yindongliang/article/details/79708404?utm_source=blogxgwz7]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-next主题设置]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F03%2F15%2FGit%2FHexoBlog%2Fhexo-next%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[NexT主题设置只主要针对于个人Next主题下 Pisces 的设置 使用主题： 进入博客根目录 /themes/ , 执行 $git clone ... 命令，将主题克隆下来 或者直接将主题下载并解压到博客根目录 /themes/，这种方法没有版本信息，也就是隐藏文件夹git 左侧菜单设置菜单设置打开 themes/next/_config.yml 文件，搜索 menu_icons 关键字，修改对应图标名称或者新增对应 menu 的图标。 显示菜单图标将 menu_icons 设置为 enable: true 123456789101112131415161718192021222324252627# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).# Usage: `Key: /link/ || icon`# Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.# Value before `||` delimeter is the target link.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.menu: home: / || home archives: /archives/ || history categories: /categories/ || list tags: /tags/ || tags tools: /categories/工具资源/ || briefcase about: /about/ || user #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons.# Icon Mapping:# Map a menu item to a specific FontAwesome icon name.# Key is the name of menu item and value is the name of FontAwesome icon. Key is case-senstive.# When an question mask icon presenting up means that the item has no mapping icon.menu_icons: enable: true 网站标题栏背景颜色使用Pisces主题时，网站标题栏背景颜色是黑色的，感觉不好看，可以在 source/css/_schemes/Pisces/_brand.styl 中修改： .site-meta { padding: 20px 0; color: white; background: $blue-dodger; //修改为自己喜欢的颜色 +tablet() { box-shadow: 0 0 16px rgba(0,0,0,0.5); } +mobile() { box-shadow: 0 0 16px rgba(0,0,0,0.5); } } 头像设置加旋转打开 themes/next/_config.yml 文件，搜索 Sidebar Avatar 关键字，去掉 avatar 前面的#： # Sidebar Avatar # in theme directory(source/images): /images/avatar.jpg # in site directory(source/uploads): /uploads/avatar.jpg avatar: http://example.com/avatar.png 或者使用本地图片,把图片放入 themes/next/source/images 下,修改 avatar： avatar: /images/avatar.gif 设置头像边框为圆形框打开位于 themes/next/source/css/_common/components/sidebar/sidebar-author.syl 文件,修改如下: .site-author-image { display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; // 修改头像边框 border-radius: 50%; -webkit-border-radius: 50%; -moz-border-radius: 50%; } 鼠标放置头像上旋转(themes/next/source/css/_common/components/sidebar/sidebar-author.syl) .site-author-image { display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; // 修改头像边框 border-radius: 50%; -webkit-border-radius: 50%; -moz-border-radius: 50%; // 设置旋转 transition: 1.4s all; } // 可旋转的圆形头像,`hover`动作 .site-author-image:hover { -webkit-transform: rotate(360deg); -moz-transform: rotate(360deg); -ms-transform: rotate(360deg); -transform: rotate(360deg); } 签名设置设置侧边栏社交链接和图标打开 themes/next/_config.yml 文件,搜索关键字 social ,然后添加社交站点名称与地址即可。(||后面为图标) # --------------------------------------------------------------- # Sidebar Settings # --------------------------------------------------------------- # Social Links. # Usage: `Key: permalink || icon` # Key is the link label showing to end users. # Value before `||` delimeter is the target permalink. # Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded. social: E-Mail: mailto:yourname@gmail.com || envelope Google: https://plus.google.com/yourname || google Twitter: https://twitter.com/yourname || twitter FB Page: https://www.facebook.com/yourname || facebook # 等等 友情链接打开 themes/next/_config.yml 文件,搜索关键字 Blog rolls： # Blog rolls links_title: 友情链接 #标题 links_layout: block #布局，一行一个连接 #links_layout: inline links: #连接 baidu: http://example.com/ google: http://example.com/ rss本地搜索在站点的根目录下 $ npm install hexo-generator-searchdb --save 打开 Hexo 站点的 _config.yml,添加配置 search: path: search.xml field: post format: html limit: 10000 打开 themes/next/_config.yml ,搜索关键字 local_search ,设置为 true： # Local search # Dependencies: https://github.com/flashlab/hexo-generator-search local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 ps:注意不要设置背景透明那里会导致这有点问题 设置菜单跳转页面、404界面新建菜单页面在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 categories ： $ cd your-hexo-site $ hexo new page categories 编辑刚新建的页面,设置分类 --- title: 分类 date: 2014-12-22 12:39:04 categories: Testing #分类名 type: &quot;categories&quot; --- 其他的操作一样 新建404界面在站点根目录下,输入 hexo new page 404 ,默认在 Hexo 站点下 /source/404/index.md打开新建的404界面，在顶部插入一行，写上 permalink: /404 ，这表示指定该页固定链接为 http://&quot;主页&quot;/404.html 。 --- title: #404 Not Found：该页无法显示 date: 2017-09-06 15:37:18 comments: false permalink: /404 --- 不想编辑属于自己的404界面,可以显示腾讯公益404界面,代码如下： &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8;&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;all&quot; /&gt; &lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://qzone.qq.com/gy/404/style/404style.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/plain&quot; src=&quot;http://www.qq.com/404/search_children.js&quot; charset=&quot;utf-8&quot; homePageUrl=&quot;/&quot; homePageName=&quot;回到我的主页&quot;&gt; &lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/data.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://qzone.qq.com/gy/404/page.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在右上角或者左上角实现fork me on github第一种风格链接 第二种风格链接 选择好样式之后直接将样式的标签复制（复制框内代码）,,将如下地方代码换为自己Github主页： 打开 themes/next/layout/_layout.swig 文件，把代码复制到 &lt;div class=&quot;headband&quot;&gt;&lt;/div&gt; 下面。 添加网易云音乐在网易云音乐（网页版）中搜索我们想要插入的音乐，然后点击生成外链播放器 根据设置生成相应的html代码，将获得的html代码插入到你想要插入的位置 放在侧边栏，在 themes/next/layout/_custom/sidebar.swig 文件中增加生成的HTML代码： &lt;div id=&quot;music163player&quot;&gt; &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=280 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=38358214&amp;auto=0&amp;height=66&quot;&gt; &lt;/iframe&gt; &lt;/div&gt; 文章post设置主页文章添加边框阴影效果首页只显示标题 不显示过多的博客内容 打开 themes/next/source/css/_custom/custom.styl ,向里面加代码: // 主页文章添加阴影效果 .post { margin-top: 0px; margin-bottom: 60px; //每篇post的间隔 padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); } 修改文章间分割线打开 themes/next/source/css/_common/components/post/post-eof.styl ,修改： .posts-expand { .post-eof { display: block; // margin: $post-eof-margin-top auto $post-eof-margin-bottom; width: 0%; //分割线长度 ,从8%改为0% height: 0px; // 分割线高度 从1px改为0 即不显示 background: $grey-light; text-align: center; } } 文章标题下的信息显示（更新时间和文字数量、统计等）更新时间打开主题配置文件 _config.yml ,搜索关键字 updated_at 设置为 true ： # Post meta display settings post_meta: item_text: true created_at: true updated_at: ture categories: true 文字数量统计在站点的根目录下安装统计功能： $ npm i --save hexo-wordcount 打开 themes/next/_config.yml ，搜索关键字 post_wordcount： # Post wordcount display settings # Dependencies: https://github.com/willin/hexo-wordcount post_wordcount: item_text: true #字数统计 wordcount: true #预览时间 min2read: true #总字数,显示在页面底部 totalcount: true separated_meta: true 增加底部版权信息阅读完成标志每篇文章末尾统一添加“本文结束”标记在路径 /themes/next/layout/_macro 中新建 passage-end-tag.swig 文件,并添加以下内容： &lt;div&gt; {% if not is_index %} ------ 本文结束------ {% endif %} &lt;/div&gt; 打开 themes/next/layout/_macro/post.swig 文件,添加： &lt;div&gt; {% if not is_index %} {% include 'passage-end-tag.swig' %} {% endif %} &lt;/div&gt; 然后打开主题配置文件 _config.yml,在末尾添加： # 文章末尾添加“本文结束”标记 passage_end_tag: enabled: true 整体页面设置设置主题风格打开 themes/next/_config.yml 文件，搜索 scheme 关键字，将你需用启用的 scheme 前面注释 # 去除即可。 # --------------------------------------------------------------- # Scheme Settings # --------------------------------------------------------------- # Schemes #scheme: Muse # 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 #scheme: Mist # Muse 的紧凑版本，整洁有序的单栏外观 scheme: Pisces # 双栏 Scheme，小家碧玉似的清新 #scheme: Gemini # 类似 Pisces 网址图标、网站标题、作者、语言设置设置网站的图标Favicon 在EasyIcon中找一张（32*32）的ico图标,或者去别的网站下载或者制作，并将图标名称改为 favicon.ico (对应原文件名称覆盖也可以),然后把图标放在 /themes/next/source/images 里，并且修改主题配置文件： small: /images/favicon-16x16-next.png medium: favicon.ico apple_touch_icon: /images/apple-touch-icon-next.png safari_pinned_tab: /images/logo.svg 在博客配置文件 _config.yml 中进行如下配置 # Site title: ArronYang subtitle: description: 吾辈岂是蓬蒿人 author: AaronYang language: zh-Hans # 时区，如不填，则表示默认电脑的时区 timezone: 添加背景图 （本地图预览无效）选取图片放到 /themes/next/source/images 下，url放对应名称 @media screen and (min-width:1200px) { body { background-image:url(/images/bg.jpg); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size:100% 100%; } #footer a { color:#eee; } } 实现点击出现桃心效果（预览无效）复制以下代码 !function(e,t,a){function n(){c(&quot;.heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}&quot;),o(),r()}function r(){for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)}function o(){var t=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e){t&amp;&amp;t(),i(e)}}function i(e){var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,d.push({el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()}),t.body.appendChild(a)}function c(e){var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try{a.appendChild(t.createTextNode(e))}catch(t){a.styleSheet.cssText=e}t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)}function s(){return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;}var d=[];e.requestAnimationFrame=function(){return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)}}(),n()}(window,document); 新建 love.js 文件并且将代码复制进去，然后保存。 将 love.js文件放到路径 /themes/next/source/js/src 里面 然后打开 \themes\next\layout_layout.swig 文件,在末尾（在前面引用会出现找不到的bug）添加以下代码： &lt;!-- 页面点击小红心 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 修改内容区域的宽度添加加载条和风格打开 themes/next/_config.yml ，搜索关键字 pace ,设置为 true ,可以更换加载样式： # Progress bar in the top during page loading. pace: true # Themes list: #pace-theme-big-counter #pace-theme-bounce #pace-theme-barber-shop #pace-theme-center-atom #pace-theme-center-circle #pace-theme-center-radar #pace-theme-center-simple #pace-theme-corner-indicator #pace-theme-fill-left #pace-theme-flash #pace-theme-loading-bar #pace-theme-mac-osx #pace-theme-minimal # For example # pace_theme: pace-theme-center-simple pace_theme: pace-theme-bounce #替换更换样式 浏览页面的时候显示当前浏览进度 （回到顶部百分比显示）打开 themes/next/_config.yml ,搜索关键字 scrollpercent ,把 false 改为 true。 # Scroll percent label in b2t button scrollpercent: true foot底部信息设置 其余第三方服务让百度收录博客站点在刚建站的时候各个搜索引擎是没有收录我们网站的，在搜索引擎中输入 site:&lt;域名&gt; 如果提示没有找到说明没有被搜索引擎收录 评论https://vonsdite.cn/https://www.jianshu.com/p/efbeddc5eb19https://www.jianshu.com/p/b520b49562b2 Hexo主题下载 Next的官方网址 Next的GitHub地址]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[github创建依赖库]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F03%2F07%2FGit%2FGithub%2Fgithub%E5%88%9B%E5%BB%BA%E4%BE%9D%E8%B5%96%E5%BA%93%2F</url>
    <content type="text"><![CDATA[使用JitPack创建自己的依赖库流程如下： 1.创建library项目 2.上传library项目到github 3.使用jitpack生成依赖 4.使用到项目中 创建library1通过 File-&gt;New-&gt;New Module,选择library，创建新的module项目. 或者将原项目的build.gradle内的apply（一般在第一行） apply plugin: &apos;com.android.application&apos; 修改成 apply plugin: &apos;com.android.library&apos; 就可以创建一个Module 2.Module 需要添加maven依赖 要在jitpack使用的话，需要添加maven依赖。 在根目录的build.gradle加入maven-plugin dependencies { ... classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.4.1&apos; } 项目的build.gradle添加 ... apply plugin: &apos;com.github.dcendents.android-maven&apos; 上传项目至github直接创建仓库，参考之前的项目上传 生成依赖1.项目上传之后，提交release 2.打开 https://jitpack.io/ 并将 github 的项目地址填入，点击 Look Up，会看到刚刚提交的 release 的版本号在列表中 3.点击 get it 后，等待 build 完成，显示为绿色图标后，就可以在你的项目内添加依赖使用了。使用只需要2个步骤: 在需要使用的项目根目录添加 allprojects { repositories { ... maven { url &apos;https://jitpack.io&apos; } } } 在项目添加依赖（以本项目为例） dependencies { compile &apos;com.github.look0089:MyDialog:v1.7&apos; } 给依赖库打上图标标记（可选）常见问题：1、library 中不能使用 switch case，会报错。需改成 if else。 2、JitPack 的 列表是根据 GitHub 的 Release 来获取的。而 Release 的顺序并不是按照提交顺序排序，似乎是根据 Tags 的字母排序。 3、报错：Unable to load class ‘org.gradle.api.internal.artifacts.ImmutableModuleIdentifierFactory’.需要检查一下项目对应的 gradle 版本，否则第二步的 Module 添加 maven 依赖 时编译会提示找不到 class 文件。 总结参考]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>依赖库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上传项目至github]]></title>
    <url>%2FAaronYang23.github.io%2F2019%2F01%2F09%2FGit%2FGithub%2Fgithub%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[上传项目至github1.安装好git和已有github账号的情况下，直接创建新仓库，相应介绍： Repository name: 仓库名称 Description(可选): 仓库描述介绍 Public, Private : 仓库权限（公开共享，私有或指定合作者） Initialize this repository with a README: 添加一个README.md gitignore: 不需要进行版本管理的仓库类型，对应生成文件.gitignore license: 证书类型，对应生成文件LICENSE 创建完成后点击Clone or dowload会出现一个地址，复制此地址，选一个目录并git clone下来即可。 2.添加ignore touch .gitignore //生成“.gitignore”文件 忽略文件可以参考GitHub gitigonore，更多ignore操作查阅之前的git总结 参考]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阴影效果]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F12%2F07%2FAndroid%2FUI%2F%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[阴影效果文字阴影演示效果图: 阴影效果&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;30dp&quot; android:shadowColor=&quot;#FF000000&quot; android:shadowDx=&quot;5&quot; android:shadowDy=&quot;5&quot; android:shadowRadius=&quot;3&quot; android:text=&quot;阴影效果&quot; android:textColor=&quot;#FFF&quot; android:textSize=&quot;30sp&quot; /&gt; 浮雕效果&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;30dp&quot; android:shadowColor=&quot;#ccc&quot; android:shadowDx=&quot;0.5&quot; android:shadowDy=&quot;0.5&quot; android:shadowRadius=&quot;2&quot; android:text=&quot;浮雕效果&quot; android:textColor=&quot;#FF000000&quot; android:textSize=&quot;30sp&quot; /&gt; ##图片阴影]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音乐播放]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F11%2F18%2FAndroid%2F%E9%9F%B3%E8%A7%86%E9%A2%91%2F%E9%9F%B3%E9%A2%91%2F%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE%EF%BC%88%E4%B8%80%EF%BC%89-Media%20Player%2F</url>
    <content type="text"><![CDATA[#Android 音乐播放 MediaPlayer MediaPlayer其实是一个封装的很好的音频、视频流媒体操作类，如果查看其源码，会发现其内部是调用的native方法，所以它其实是有C++实现的。既然是一个流媒体操作类，那么必然涉及到，播放、暂停、停止等操作，实际上MediaPlayer也为我们提供了相应的方法来直接操作流媒体。 1、播放Raw下的元数据//直接创建，不需要设置setDataSource mMediaPlayer=MediaPlayer.create(this, R.raw.audio); mMediaPlayer.start(); 2、MediaPlayer设置播放源的4中方式 setDataSource (String path) //从sd卡中加载音乐 mMediaPlayer.setDataSource(&quot;../music/samsara.mp3&quot;) ; //从网路加载音乐 mMediaPlayer.setDataSource(&quot;http://..../xxx.mp3&quot;) ; //需使用异步缓冲 mMediaPlayer.prepareAsync() ; setDataSource (FileDescriptor fd) //需将资源文件放在assets文件夹 AssetFileDescriptor fd = getAssets().openFd(&quot;samsara.mp3&quot;); mMediaPlayer.setDataSource(fd) mMediaPlayer.prepare() ; Ps:此方法系统需大于等于android setDataSource (Context context, Uri uri) 一般通过ContentProvider获取Android系统提供的共享music获取uri，然后设置数据播放 setDataSource (FileDescriptor fd, long offset, long length) //需将资源文件放在assets文件夹 AssetFileDescriptor fd = getAssets().openFd(&quot;samsara.mp3&quot;); mMediaPlayer.setDataSource(fd, fd.getStartOffset(), fd.getLegth()) mMediaPlayer.prepare() ; 播放assets文件 3、注意点 设置完数据源，不要忘记prepare()，尽量使用异步prepareAync()，这样不会阻塞UI线程。 播放完毕即使释放资源,MediaPlayer是很消耗系统资源的，所以在使用完MediaPlayer，不要等待系统自动回收，最好是主动回收资源。 mediaPlayer.stop(); mediaPlayer.release(); mediaPlayer = null; 4、不足资源占用量较高、延迟时间较长、不支持多个音频同时播放等 5、使用1、创建MediaPlayer对象； 2、设置数据源； 3、调用prepare，防止卡界面用异步方式prepareAsyc（）； 4、设置onPrepare监听，异步加载完之后条用start()播放 5、切换数据源先调用reset然后调用setDataSource 6、释放资源 /** * desc: 播放 */ private void play(File file) { if (player == null) { player = new MediaPlayer(); } if (player.isPlaying()) { player.stop(); } player.reset(); try { player.setDataSource(file.getAbsolutePath()); player.prepareAsync(); player.setOnPreparedListener(new MediaPlayer.OnPreparedListener() { @Override public void onPrepared(MediaPlayer mp) { player.start(); } }); } catch (IOException e) { e.printStackTrace(); } } 7、进度控制 通过使用mediaplayer.getcurrent();获得当前的播放时间进度，单位为100毫秒 通过使用mediaplayer.getDuration();获得播放总持续时间，这是进度，然后启动一个子线程回调进程即可 //设置进度条最大进度 ((Fragment2) getParentFragment()).getPlayProgress().setMax(player.getDuration()); new Thread(new Runnable() { @Override public void run() { while (!isPlayComplete) { if (player.isPlaying()) { //设置进度 ((Fragment2) getParentFragment()).getPlayProgress().setProgress(player.getCurrentPosition()); try { Thread.sleep(100);//睡眠100毫秒 } catch (Exception e) { e.printStackTrace(); } } } } } }).start(); 6、APIvoid statr()：开始或恢复播放。 void stop()：停止播放。 void pause()：暂停播放。 通过上面三个方法，只要设定好流媒体数据源，即可在应用中播放流媒体资源，为了更好的操作流媒体，MediaPlayer还为我们提供了一些其他的方法，这里列出一些常用的，详细内容参阅官方文档。 int getDuration()：获取流媒体的总播放时长，单位是毫秒。 int getCurrentPosition()：获取当前流媒体的播放的位置，单位是毫秒。 void seekTo(int msec)：设置当前MediaPlayer的播放位置，单位是毫秒。 void setLooping(boolean looping)：设置是否循环播放。 boolean isLooping()：判断是否循环播放。 boolean isPlaying()：判断是否正在播放。 void prepare()：同步的方式装载流媒体文件。 void prepareAsync()：异步的方式装载流媒体文件。 void release ()：回收流媒体资源。 void setAudioStreamType(int streamtype)：设置播放流媒体类型。 void setWakeMode(Context context, int mode)：设置CPU唤醒的状态。 setNextMediaPlayer(MediaPlayer next)：设置当前流媒体播放完毕，下一个播放的MediaPlayer。 大部分方法的看方法名就可以理解，但是有几个方法需要单独说明一下。 在使用MediaPlayer播放一段流媒体的时候，需要使用prepare()或prepareAsync()方法把流媒体装载进MediaPlayer，才可以调用start()方法播放流媒体。 setAudioStreamType()方法用于指定播放流媒体的类型，它传递的是一个int类型的数据，均以常量定义在AudioManager类中， 一般我们播放音频文件，设置为AudioManager.STREAM_MUSIC即可。 除了上面介绍的一些方法外，MediaPlayer还提供了一些事件的回调函数，这里介绍几个常用的： setOnCompletionListener(MediaPlayer.OnCompletionListener listener)：当流媒体播放完毕的时候回调。 setOnErrorListener(MediaPlayer.OnErrorListener listener)：当播放中发生错误的时候回调。 setOnPreparedListener(MediaPlayer.OnPreparedListener listener)：当装载流媒体完毕的时候回调。 setOnSeekCompleteListener(MediaPlayer.OnSeekCompleteListener listener)：当使用seekTo()设置播放位置的时候回调。 SoundPool参考 Android中播放音乐的几种方式]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>音频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程相关的错误]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F11%2F09%2FAndroid%2F%E5%9F%BA%E7%A1%80%2F%E7%BA%BF%E7%A8%8B%26%E5%BC%82%E6%AD%A5%2F%E7%BA%BF%E7%A8%8B%E9%94%99%E8%AF%AF%E6%94%B6%E5%BD%95%2F</url>
    <content type="text"><![CDATA[java.lang.IllegalThreadStateException原因：线程还没结束的时候又调用了start，Android中线程即使run已经走完了，要过一会线程才会停止，连续点击就会重新start报错，如果想循环使用线程，则使用创建Runnable对象+new Thread的方式。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音频播放(二) SoundPool]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F11%2F03%2FAndroid%2F%E9%9F%B3%E8%A7%86%E9%A2%91%2F%E9%9F%B3%E9%A2%91%2F%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE%EF%BC%88%E4%BA%8C%EF%BC%89-SoundPool%2F</url>
    <content type="text"><![CDATA[SoundPool相较于Mediaplay，SoundPool可以理解为多音频的播放器，可以分别控制每个音轨上的音频同时播放。实际工作中目前有适用于有背景音乐和掌声等特性同时播放分别控制音量的场景。 特点： SoundPool适合 短小的 声音文件 SoundPool适合播放 “需要多次播放的提示音”，比如在一些常用的请登录，请点击之类 相比mediaPlayer，耗用资源更少 支持同时播放多个声音 每个音频文件大小要小于100k；可以修改音频码率来压缩音频大小，把 128kbps改成32kbps 使用1、初始化SoundPool 注：new SoundPool的方法已经过时 //过时,参数1表示允许同时播放的流的最大值，参数2表示流的类型，参数3表示采样率转化质量，默认值为0 //SDK_INT 21 以下 SoundPool soundPool = new SoundPool(1, AudioManager.STREAM_MUSIC,0); //新的API，高于SDK_INT 21 AudioAttributes abs = new AudioAttributes.Builder() .setUsage(AudioAttributes.USAGE_MEDIA) .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC) .build() ; SoundPool.Builder spb = new SoundPool.Builder(); spb.setMaxStreams(1); // 同时播放的流的最大数量 spb.setAudioAttributes(abs); //流的类型，一般为STREAM_MUSIC(具体在AudioManager类中列出),完全可以设置为null soundPool = sb.build(); 2.播放音乐,和mediaplay一样先加载，有加载监听，加载完成后可以播放 //加载完成监听 soundPool.setOnLoadCompleteListener(new SoundPool.OnLoadCompleteListener() { @Override public void onLoadComplete(SoundPool soundPool, int sampleId, int status) { Log.i(&quot;=======&quot;,&quot;=======加载完成开始播放&quot;); } }); //加载音频，如果加载成功返回非0的int值，通过知否为0可以判断,参数二为优先级 soundID = soundPool.load(path,1); //其余加载方式 //int load(Context context, int resId, int priority) //从APK资源载入 //int load(FileDescriptor fd, long offset, long length, int priority) //从FileDescriptor对象载入 //int load(AssetFileDescriptor afd, int priority) //从Asset对象载入 //int load(String path, int priority) //从完整文件路径名载入 //播放音频，成功返回非0的streamId //参数1加载完成的音频id，参数2左声道音量，参数3右声道音量 //参数4优先级，值越大优先级高， //参数5循环次数，0为值播放一次，-1为无限循环，其他值为播放loop+1次（例如，3为一共播放4次）. //参数6速率，范围0.5-2.0(0.5为一半速率，1.0为正常速率，2.0为两倍速率) streamID = soundPool.play(soundID,1.0f,1.0f,0,0,1.0f); 这里注意：load完成后会返回一个soundId表示的是加载完成的音频，play方法会返回一个streamId表示的是这个音频对应的音频流，soundpool对这个音频的控制（包括继续播放、暂停、停止、音量调节）都是通过streamId控制。 3、播放控制 //播放 streamID = soundPool.play(soundID,1.0f,1.0f,0,0,1.0f); //暂停 soundPool.pause(streamID); //继续播放 soundPool.resume(streamID); //停止 soundPool.stop(streamID); //设置音量，参数1为streamId，参数2左声道，参数3右声道,设置的音量是当前系统音量的百分比大小 soundPool.setVolume(streamID, seekBar.getProgress() / 100.0f, seekBar.getProgress() / 100.0f); 4、资源释放 //释放一个指定的音频资源,释放后需要重新load final boolean unload(int soundID) //释放SoundPool中的所有音频资源. final void release() 补充1.目前没有找到SoundPool可以显示进度的方法，可能因为soundpool本来就是用来播放一些短音频的，类似游戏枪击声这样的，所以没有找到相关Api，可做的参考是通过MediaPlay获取音频时长自己计时。 MediaPlayer player = new MediaPlayer(); try { player.setDataSource(recordingFilePath()); //recordingFilePath（）为音频文件的路径 player.prepare(); } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } double duration= player.getDuration();//获取音频的时间 Log.d(&quot;ACETEST&quot;, &quot;### duration: &quot; + duration); player.release();//记得释放资源 2.一个SoundPool可以： 管理多个音频资源，通过load()函数，成功则返回非0的soundID; 同时播放多个音频，通过play()函数，成功则返回非0的streamID; pause()、resume()和stop()等操作是针对streamID(播放流)的; 当设置为无限循环时，需要手动调用stop()来终止播放; 播放流的优先级(play()中的priority参数)，只在同时播放数超过设定的最大数时起作用; 程序中不用考虑（play触发的）播放流的生命周期，无效的soundID/streamID不会导致程序错误。 android系统一个设备只允许同时有32个音效文件播放 SoundPool的风险性1、播放只会申请1M的内存空间2、不能播放超过256次3、比特率不能太大或者太小4、文件不能过大，尽量建议不超过200kb，超过了需要压缩5、soundpool相较于Mediaplay而言更快，能够减少加载播放延迟，但依旧取决于手机性能6、有些mp3文件播放不完整，播放到后面部分就没声音了7、播放有警告：AudioTrack: AUDIO_OUTPUT_FLAG_FAST denied by client; transfer 4, track 44100 Hz, output 48000 Hz 参考 Android音频播放之SoundPool 详解 【Android】播放音频的几种方式介绍 SoundPool部分 Android音频播放之SoundPool 详解]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>音频</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成自己的依赖库]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F10%2F31%2FAndroid%2F%E8%A7%84%E8%8C%83%E5%92%8C%E6%9B%B4%E5%A4%9A%E4%BD%BF%E7%94%A8%2F%E7%94%9F%E6%88%90%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%BA%93%2F</url>
    <content type="text"><![CDATA[如何做自己的依赖库分享给别人使用我们平时做项目经常会依赖别人写好的库，有的时候自己总结的一些东西有时候也想封装起来，不说别人用不用的上，就是自己能使用依赖的方式使用也比复制文件要强，所以学会做自己的依赖库很方便。这里的库指的是jitpack仓库。 发布自己Library流程1、新建一个项目作为根仓库2、New一个module，选择lib模式 3、修改两个build.gradle-项目的build buildscript { repositories { jcenter() } dependencies { classpath &apos;com.android.tools.build:gradle:2.3.3&apos; classpath &apos;com.github.dcendents:android-maven-gradle-plugin:1.5&apos; } } allprojects { repositories { jcenter() maven { url &apos;https://jitpack.io&apos; } } } task clean(type: Delete) { delete rootProject.buildDir } - library下的build apply plugin: &apos;com.android.library&apos; apply plugin: &apos;com.github.dcendents.android-maven&apos; group=&apos;com.github.AaronYang23&apos;// AaronYang23代表你github名字 4、运行gradle指令Terminal下输入指令： gradlew install 之前作者没做这一个步骤，然后进入jitpack的时候库会报错，报错日志如下： 然后项目是无法引用的，因为没通过，搜索排查之后是这里没有执行，执行这一步又报错 F:\customlibs\PermissionUtil\mylib&gt;gradlew build --info 错误: 找不到或无法加载主类 org.gradle.wrapper.GradleWrapperMain 不能使用终端gradlew命令，找到原因是因为项目中gradle-wrapper.jar缺失，可是明明看到gradle下有gradlewrapper.jar还是报错，后来才发现是因为公司有加密的软件使得无法解析使用。处理了就好了 5、代码上传到git仓库使用git的基本操作push代码至仓库中 6、项目发布版本 7、到Jitpack 开启可搜索 8、测试自己的依赖库直接加入引用即可，记得tag要更换，如果有关于最小API的报错，是因为库中可支持的最小api与实际项目中的设置不一样，修改库中build.gradler重新发布即可,然后可以添加readme好好描述库的功能和使用讲解 9.上面的步骤是在已经提前在github创建仓库了，第二种方式是集成进了AndroidStudio里面，更好使用，推荐第二种1、AS绑定github 后面的步骤就是直接创建仓库并且上传代码了，后面的步骤发布上线与前面的是一致的,区别只是方便一点不需要再去github创建仓库了 指令gradlew -v 查看gradle版本 gradlew install 初始化 参考 Android发布Library到JitPack 错误: 找不到或无法加载主类 org.gradle.wrapper.GradleWrapperMain Android Studio如何制作依赖库]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>依赖库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反编译]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F10%2F20%2FAndroid%2F%E4%B8%8A%E7%BA%BF%2F%E5%AE%89%E5%85%A8%2F%E5%8F%8D%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[反编译获取源码1、准备工具： apktool （资源文件获取） : 下载地址 dex2jar（源码文件获取）:下载地址 jd-gui （源码查看）:下载地址 2、反编译流程:资源文件：将apk的后缀改为rar打开即可代码： 1、将apk后缀改为rar打开获取classes.dex文件 2、将classes.dex文件放于解压出来的工具【dex2jar-2.0】文件夹内 3、cmd定位到【dex2jar-2.0】文件夹目录执行指令： d2j-dex2jar classes.dex 得到classes-得闲jar.jar文件 4、运行jd-gui.exe工具，将上面得到的jar文件拖进即可查看源码 获取资源文件如果直接解压.apk文件，xml文件打开全部是乱码，所以资源获取需要另外反编译 1、新版本apktool用法：下载：https://ibotpeaches.github.io/Apktool/install/ 2、操作： 下载完成后，运行CMD，进入比如app-release.apk所在目录，然后运行apktool d app-release.apk就可以了，默认解压的文件就在app-release.apk所在目录。 apktool d xxx.apk]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>andorid安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle 配置解析]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F10%2F16%2Fframework%2FGradle-%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[gradle作用gradle是一个以Groovy语言为基础的构建工具，要面向的是Java语言，在studio中的作用主要为： 项目设置配置 导入jar包 签名打包 gradle离线下载 卡在gradle building:Android Studio导入项目的时候，需要下载项目对应的gradle包，主因为在国内防火墙屏蔽的原因，导致下载的速度蜗牛般慢，所以会一直卡停在这个界面 方法一：修改项目的gradle-wrapper.properties里的gradle版本把原有的gradle-xx-all.zip包修改为当前版本，如果不知道值为多少，找一个你之前能够运行的AS项目，然后在文件夹下找到gradle-wrapper.properties，复制distributionUrl属性。在新的项目中找到build.grable修改为其值，重启Android Studio即可 方法一：离线包下载导入原因是自动下载不成功，那么我们可以手动下载回来，然后进行导入进去，查看所需gradle版本，打开C:\Users\用户名.gradle\wrapper\dists\gradle-x.xx-all\xxxxxxxxxxxx如果里面的gradle-xx-all.zip不完整（如0KB），则说明下载不成功，需要下载离线包放置到该目录下,也可以直接去导入的项目中查看设置的gradle 版本gradle版本下载 关于gradle版本首先分清gradle版本和gradle插件版本。一个是基本，一个是一些语法和方法的版本 File -&gt; Project Structrue 查看或者修改当前项目的gradle信息，或者快捷键 Ctrl+Alt+Shift+S 项目根目录下builde.gradle -&gt; dependencies -&gt; classpath ‘com.android.tools.build:gradle:4.1.1’ 是gradle插件版本 更新gradle app下的build.gradle 基本// 表示这是一个Android程序模块，如果是作为库，就声明为Library&apos;com.android.library&apos; apply plugin: &apos;com.android.application&apos; android { compileSdkVersion 26 // 编译版本，指用哪个版本的SDK进行编译 buildToolsVersion &quot;26.0.1&quot; //构建工具 //对项目的更多细节进行配置 defaultConfig { applicationId &quot;com.seachal.myapplicationtestlog&quot; minSdkVersion 19 targetSdkVersion 26 versionCode 1 versionName &quot;1.0&quot; flavorDimensions &quot;default&quot; //版本名后面添加一句话，意思就是flavor dimension 它的维度就是该版本号，这样维度 //就是加入default都是统一的了,不过最好在属性里 testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; multiDexEnabled false //方法数超过65k后,添加多 dex分包支持 } //签名配置文件 signingConfigs { release { keyAlias &apos;***&apos; keyPassword &apos;***&apos; //这个写具体详细路径 storeFile file(&apos;F:/SeekNatureApp_Android/SeekNatureApp/seeknature.jks&apos;) storePassword &apos;***&apos; } debug { //调试包，可以直接配置上线包的签名，便于第三方的一些配置不需要再去修改 keyAlias &apos;***&apos; keyPassword &apos;***&apos; //这个写具体详细路径 storeFile file(&apos;F:/SeekNatureApp_Android/SeekNatureApp/seeknature.jks&apos;) storePassword &apos;***&apos; } } //指定生成安装文件的相关配置 buildTypes { //release 闭包用于指定生成正式版安装文件的配置 release { zipAlignEnabled true //资源按4字节对齐 minifyEnabled false ////是否进行混淆 shrinkResources true//去掉不用资源 proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; //混淆文件的位置 signingConfig signingConfigs.release //签名配置，引用signingConfigs } //debug闭包可以忽略不写，但是需要签名文件的话需要加上签名配置 debug { // minifyEnabled true // proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; signingConfig signingConfigs.release } } //友盟的多渠道打包 /*配置渠道*/ productFlavors.all { flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] } //渠道名称 productFlavors { debug_test {} seekna {} //公司渠道 ... } //加入自定义打包时apk名称配上渠道号 applicationVariants.all { variant -&gt; variant.outputs.all { output -&gt;// each 改为 all def fileName = &quot;sknature_${variant.productFlavors[0].name}_${variant.versionName}.apk&quot; def outFile = output.outputFile if (outFile != null &amp;&amp; outFile.name.endsWith(&apos;.apk&apos;)) { outputFileName = fileName // output.outputFile 改为 outputFileName } } } } //依赖库 dependencies { //本地依赖声明，它表示将 libs 目录下所有.jar 后缀的文件都添加到项目的构建路径当中 implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, { exclude group: &apos;com.android.support&apos;, module: &apos;support-annotations&apos; }) // 声明测试用例库 testCompile &apos;junit:junit:4.12&apos; // 远程依赖声明 implementation &apos;com.android.support:appcompat-v7:26.+&apos; ... } moudle下的build.gradle// buildscript里是gradle脚本执行所需依赖，分别是对应的maven库和插件 buildscript { repositories { //仓库,默认是jcenter，之前版本则是mavenCentral，也可以两个center共存。 //jcenter可以理解成是一个新的中央远程仓库，兼容maven中心仓库，而且性能更优。 google() jcenter() mavenCentral() // add repositSory } dependencies { // 依赖 classpath &apos;com.android.tools.build:gradle:3.1.3&apos; classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.2&apos; // add plugin // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle filesd } } // allprojects里是项目本身需要的依赖,比如我现在要依赖我自己maven库的toastutils库，那么我应该将 // maven {url ‘https:// dl.bintray.com/calvinning/maven‘}写在这里，而不是buildscript中，不然找不到。 allprojects { repositories { mavenCentral() google() jcenter() maven { url &quot;https://jitpack.io&quot; } } } //声明了一个任务，任务名叫clean（也可以改为其它），任务类型是Delete（也可以是Copy），就是每当修改settings.gradle文件 //点击同步，就会删除rootProject.buildDir下的文件(实际上我看到的效果是清除了External //Libraries里的包，然后又添加了一//次)。 task clean(type: Delete) { delete rootProject.buildDir } buildscript下的第一个子“节点”是声明仓库源， 参考 app目录下的build.gradle详解 学习Android Studio里的Gradle buildscript和allprojects的作用和区别是什么？]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[运行时异常收录 (Android)]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F10%2F10%2FAndroid%2F%E4%B8%8A%E7%BA%BF%2F%E9%A1%B9%E7%9B%AE%E5%8A%9F%E8%83%BD%E5%81%9A%E5%AE%8C%E5%90%8E%E8%AF%A5%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85%2F</url>
    <content type="text"><![CDATA[#项目如果所有的界面、功能都做完了，应该做些什么？ 基本阶段：1.资源缩减2、混淆-反编译、加固3、稳定性测试-平台测试 扩展阶段：4、加入bugly手机崩溃日志5、热修复 项目一旦做完之后，立即交给测试部门去测试？nonono，这样是不正确的做法，即使很急于向上司传达，我功能终于都做完了XD，但是也尽量不要这么做，因为毕竟刚刚做完的项目，程序员首先应该做的事情就是自测，毕竟谁也不敢保证自己的逻辑和代码是完美的。以下就说一下Android项目完成之后正确该做的事情： ##Monkey稳定性测试monkey是Android自动化测试的一种手段，目前市场上对于新上传的应用都会先对apk包进行monkey测试。monkey测试很简单，就和其名字一样，模拟猴子的行为去对应用进行无逻辑的输入、触摸，看应用会不会随时间和行为出现异常。monkey测试也称稳定性测试或者随机测试。 设计文档设计文档应该在项目中期就开始编写，一般在界面都搭建完成之后。只有在初始版本开发的时候写，作用是将一些功能模块的设计和模型记录下来，便于后面的二次开发和迭代。 ###使用说明（开发者向）monkey是adb中的一个命令行工具，是可以运行在真机或者模拟器中，向系统发送伪随机的用户事件流，实现对正在开发的应用进行压力测试。Monkey选项大致分为四大类： Monkey命令：adb shell monkey -p &lt;your.package.name&gt; –throttle 380 -v -s 3500 300000 &gt; C:\monkey_log.txt，这个monkey 命令，当monkey test 过程中遇到Crash 或者ANR，就会自动终止. adb shell monkey -p com.xy.android.junit -s 500 --ignore-crashes --ignore-timeouts --monitor-native-crashes -v -v 10000 &gt; E:\monkey_log\java_monkey_log.txt 基本配置选项，如设置尝试的事件数量]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>上线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git理解]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F10%2F10%2FGit%2FGit%2FGit%E6%80%BB%E7%BB%93%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Git以及在AndroidStudio中的使用一、基本介绍1、目前世界上最先进的分布式版本控制系统，什么是分布式版本控制？ 2、层级介绍：暂存区、本地仓库，远程仓库 add暂存区 commit提交本地仓库 push远程仓库 二、如何使用1、创建账户 1、安装 Git 2、初始化：建立仓库or复制仓库 git init git clone url 2.git配置：用户名和邮箱(全局) git config --globeal user.name &quot;Your Name&quot; git config --global user.email &quot;Your Email&quot; 3、基本使用 git工作的流程是： 第1步，使用git add把文件从工作区添加到版本库中的暂存区，git add命令可以多次用； 第2步，使用git commit提交代码，就是把暂存区的所有内容提交到当前分支，更新本地仓库； 第3步，git push至远程仓库。 git add . //添加当前目录所有文件至暂存区 git commit -m &quot;log name&quot; //提交至本地仓库 引号内是自定义版本名称 git pull //对比远程服务器与本地区别，拉取最新 git push //推送远程服务器更新 git status //查看当前状态，会有操作指示 git log //查看提交日志 git reset hard HEAD~! //回退到上个提交版本 git reset hard&lt;commitId&gt; //回退到任意版本，commitId是log里的一串类似哈希值 4、配置ignore文件(.gitignore文件放置在项目根目录) 开发中有些文件不需要去提交，可以配置ignore文件去忽略，ignore只对未track的文件生效，对已经track的文件不生效 创建ignore文件： 1、在需要创建 .gitignore 文件的文件夹, 右键选择Git Bash 进入命令行，进入项目所在目录。 2、输入 touch .gitignore ，生成“.gitignore”文件。 3、在”.gitignore” 文件里输入你要忽略的文件夹及其文件就可以了。（注意格式） 格式如： .deploy_git/ node_modules/ public/ 4、配置语法 以斜杠“/”开头表示目录； 以星号“*”通配多个字符； 以问号“?”通配单个字符 “[]”包含单个字符的匹配列表； 以叹号“!”表示不忽略(跟踪) 匹配到的文件或目录； 此外，git 对于 .ignore 配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效； （1）规则：fd1/* 说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略； （2）规则：/fd1/* 说明：忽略根目录下的 /fd1/ 目录的全部内容； .ignore只能忽略那些原来没有被纳入版本控制中的文件，如果文件已经存在版本控制中，则修改.gitignore是无效的，解决办法是先把本地缓存删除（改变成为未被跟踪状态），然后提交，重新纳入版本控制系统中. git rm -r --cached . git add . git commit -m &quot;update .ignore&quot; //对单一文件取消跟踪,可以忽略这个修改。从而不用提交到库里面。 git update-index --asume-unchanged /path/file 想恢复该文件，可以用 git update-index --no-assume-unchanged /path/file 来恢复跟踪 对某个文件取消跟踪 git rm --cached readme1.txt 删除readme1.txt的跟踪，并保留在本地。 git rm --f readme1.txt 删除readme1.txt的跟踪，并且删除本地文件。 如果是对所有文件都取消跟踪的话，就是 git rm -r --cached . //不删除本地文件 git rm -r --f . //删除本地文件 5.版本回退 git reset --hard commitID //回退到某个提交版本 git reset --hard HEAD^ //回退到上个版本 Reset Type : git reset –mixed：此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息 git reset –soft：回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可 git reset –hard：彻底回退到某个版本，本地的源码也会变为上一个版本的内容，此命令 慎用！注意：选择hard时，先把当前的版本提交一下。 二、Android Studio 中使用1.setting-versioncontrol-git 2.配置完后我们点下路径后的Test按钮，若出现该Success提示框则表明配置成功： 注：配置好后我们点击Version Control的时候，在右侧会提示该项目所采用的版本控制工具，如： 若发现该路径为灰色，需要选中，点击”+” 3.使用 右键项目或者文件-git ，进行git操作即可 注意：同样，原本在新建工程时AS会自动生成.gitignore文件，忽略掉不需要进行track的文件，比如.idea文件夹、build文件夹等，但是在设置好git之后，是所有文件都track了，此时如果只添加.gitignore就不会生效。 还重新跟踪操作。 文件颜色含义： 白色：加入，已提交，无改动 灰色：版本控制已忽略文件 红色：未加入版本控制 绿色：add未commit 蓝色：commit后有修改 4.通用ignore配置 5.版本回退,log中选择某个版本然后reset 6.提交冲突解决链接 三、分支开发,见传送门分支（branch）有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 四、指令记录git -v //检查版本 git config --globeal user.name &quot;Your Name&quot; git config --global user.email &quot;Your Email&quot; git clone url //克隆仓库，url为地址 git add . //添加所有 git diff //获取暂存区与本地仓库的不同 git status //当前状态 git log //提交日志 git commit -m &quot;title&quot; //提交版本， title为自定义名字 git pull //获取远程服务器与本地仓库的不同 git push //推送到远程服务器 git remote -v //远程访问方式 git remote set-url origin url //修改远程访问方式 git log origin/master -n 3 //查看远程仓库日志 git checkout //撤销所有本地改动代码 git reset --hard 远程分支名 //本地代码回退到与git远程仓库保持一致 git reset --hard commitID //回退到某个提交版本 git reset --hard HEAD^ //回退到上个版本 //文件跟踪 track git rm --cached readme1.txt 删除readme1.txt的跟踪，并保留在本地。 git rm --f readme1.txt 删除readme1.txt的跟踪，并且删除本地文件。 git rm -r --cached . //不删除本地文件,清除本地缓存，把仓库下所有已经被跟踪的文件设置为未跟踪状态。 git rm -r --f . //删除本地文件 一些编辑状态的退出 git log 状态的退出：英文状态下按 q 分支合并信息输出的退出: linux 退出指令 中断输出信息: control + c git commit或者merge的时候会出现解释输入，退出用： 1.按键盘字母 i 进入insert(输入)模式,编辑必要的注释。说明合并的原因,编辑的内容会在第一行显示,也可不修改 2.按”Esc” 3.输入 “:wq” , 按回车键即可 个人总结&amp;心得1、关于pull - 如果没有提交，那么pull会先用当前文件和本地进行对比 - 如果本地已经提交，那么pull才是和远程服务器进行对比 - pull的操作是将本地和远程进行对比，如果有冲突则要保持和服务器的一致？ 2、使用git pull代码时，经常会碰到有冲突的情况 1、在pull之前，必须先add-commit再pull，手动解决冲突 2、使用git stash命令进行处理 1、先将本地修改存储起来 $ git stash 这样本地的所有修改就都被暂时存储起来 。是用git stash list可以看到保存的信息，暂存了本地修改之后，就可以pull了。 $ git pull pull成功之后，还原暂存的内容，其中stash@{0}就是刚才保存的标记。 $ git stash pop stash@{0} 还原之后有冲突的地方还是会提示，需要手动解决，此方式是可以先pull 传送门 git概念、原理、使用 全面介绍Android Studio中Git的使用 git - 简易指南 git取消文件跟踪 合并commit：i进入编辑模式，esc退出编辑模式，wq保存编辑 「Git」合并多个 Commit 【关于Git】历史提交的合并 git 怎样删除远程仓库的某次错误提交？]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F10%2F10%2FGit%2FHexoBlog%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[使用Hexo+Github搭建博客总结一个真正意思上的博客自然是需要在互联网的任何一个地方都能够被访问到，目前最简单的方式就是利用GitHub Pages来实现静态博客的托管。 搭建步骤1.前提环境： 安装Node.js + Git 注册Github账号 2、安装并初始化hexo:npm install -g hexo //安装hexo hexo init //初始化,选中一个作为hexo blog的目录 npm install //安装依赖 这里会出现的错误有： 报一堆警告和错误 解决方式：连接外网或者使用镜像 2.5、如果已经创建过博客，比如我一样，是把所有的博客源文件放到github上，这样去移植博客的时候，就先安装node.js，然后选一个空文件夹安装hexo 和hexo init。然后再取出github的博客仓库，将init的文件部分导入（源文件我只上传了内容和主题还有一些配置），然后检测hexo -v 是否生效即可。 因为可能之前的hexo版本会和新安装的hexo版本不一致可能运行hexo会出现配置文件的异常，只要按最新的copy过去就好了，然后有可能出现其他的错误，一步步修改就好了。 另外hexo5.0移除了swig 需要自己在hexoinit 的目录下手动安装 才能hexo s 不出问题3、完成以上步骤已经可以预览本地博客网页(在git指令输入窗口非cmd)hexo gerate //生成静态页面 hexo server //开启本地预览服务 浏览器输入http://localhost:4000/即可预览 结合github(单个仓库最大1GB，单个文件上限100MB)4、github创建博客仓库新建一个名为你的 用户名.github.io 的仓库，必须和你的github用户名保持一致，其它名称无效，博客的访问地址 http://someaccount.github.io 5、修改hexo下 _config.yml配置文件配置deployer属性- 找到deployer修改属性 deploy: type: git repo: https://github.com/AaronYang23/AaronYang23.github.io.git branch: master 6、生成静态网页发布到github1、安装自动化部署工具 作用：通过hexo d即可推送到github仓库。因此hexo不需要单独使用git进行更新控制 npm install hexp-deployer-git –save //注意翻墙 安装完成后会出现：.deploy_git文件夹 2、本地预览没问题后发布 hexo clean hexo g (like git commit) hexo d (like gut push) 可能会发生的错误： 1.ERROR Deployer not found: github //有的博客是根据3.0以下的hexo版本写的，使用的是hexo3.0之后的版本，需要做如下三件事情： 1) 安装 npm install hexo-deployer-git --save 2) 将deploy 的 type由github改为git 3) 将repository的https改为http 2.No such device or address //注意.git目录下的config文件中有没有用户身份信息 https://[userName]:[password]@github.com/[username]/project.git 安装自动化部署工具,仓库地址如果已经绑定了ssh，则要用ssh的仓库引用方式 3.本地预览无问题，部署发布之后主题空白 更改一下_config.yml文件，其中的url和root属性。 url: http://www.nideyuming.com/blog/ root: /blog root 下面应该设置成 /你的项目名 而不是/ 然后重新部署一下就成功了。 发布成功后浏览器直接访问https://aaronyang23.github.io/就可以看到博客内容了 7、设置SSH(安全外壳协议)，此操作可以放于步骤4和步骤5之间，主要就是避免push和deploy需要的账户验证 SSH作用：SSH密钥可以为了防止其他人恶意部署文件到你的仓库，因为如果正常push需要输入账户密码不安全。简单点就是免密push,每次更新需要输入github的账号和密码，不但不安全也很麻烦，设置此方式后可以运行hexo d可以直接更新博客一般是可以公司添加一个，家里添加一个 大概需要三个步骤： a)本地生成密钥对； b)设置github上的公钥； c)修改git的remote url为git协议。 设置 SSH注：如果配置的ssh不生效，不要单单只修改了.git的远程路径，还要修改外部hexo.config-&gt;deploy中的romote ####7.1、详细步骤：1、查看本地是否有ssh：SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录关键是看有没有用 something 和 something.pub 来命名的一对文件 这个 something 通常就是 id_dsa 或 id_rsa。有 .pub 后缀的文件就是公钥，另一个文件则是密钥。假如没有这些文件，或者干脆连 .ssh 目录都没有，可以用 ssh-keygen 来创建 2、本地生成ssh,一直Enter就行，生成后进默认目录查看是否有.pub文件： ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 3.复制公钥内容：打开.pub文件，可选择使用notepad++打开 4.添加ssh:进入github网站，右上角个人点击 Account Settings -&gt; 点击 SSH Keys -&gt; 点击 Add SSH key,标题自定义，key为上一步的公钥复制进去 5.检查ssh是否有效 ssh -T git@github.com 提示Hi username! You’ve successfully …access.表示设置已经成功 6、设置远程访问协议：一般就设置2种方式，https和git，已经设置了ssh方式的,应该设置为协议为git git remote -v //查看当前git远程访问协议 https://github.com/someaccount/someproject.git //https格式 git@github.com:someaccount/someproject.git//git格式 git remote set-url origin git@github.com:someaccount/someproject.git //设置为git方式 git remote -v //查看修改后的结果是否为git 7、修改hexo配置文件 _config.yml 将deployer 的repository改为ssh引用,如： repo: ssh://git@github.com/AaronYang23/AaronYang23.github.io 8、hexo g 更新本地 -&gt; hexo d 推送 可能会出现的错误：步骤6的错误 9、如果电脑配置过ssh 则在博客中的仓库地址要引用为ssh，发现及时手动修改deployer下的git配置也无效 总是报错。 8、博客个性化设置 官方Theme：Hexo Theme 个人博客收藏: archer cube yilia varaint 可能的错误： WARN No layout: index.html 运行git clone 指令获得主题后（假设是NEXT主题）， 在theme主题下保存文件夹的名称为：hexo-theme-next-0.4.0 那么如果在config里设置的是next，就会出现这样的WARN，http://localhost:4000/显示的是空白。 只要把theme下的文件夹名称改为next就显示正常了。 同样是空白页面的记得查看下主题下的名字和文件夹层次是否对应 9、博客更新做完上面的步骤，自己的个人博客站已经搭好了，剩下的就是如何写博客和更新博客了： -hexo new “Hello” //创建一篇新博客，标题为hello -hexo generate //形成web，更新 -hexo server //本地预览，启动模拟服务器，查看刚刚新加的博客有没有成功更新上去 浏览器打开 http://localhost:4000/ 进行预览 -hexo deploy //部署置远程服务器，即更新至github ps:如果像我一样有用一个仓库进行博客的源文件保存，那切出去再进行git的相关操作就好了 指令记录-ssh ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; //生成ssh ssh -T git@github.com //验证ssh git git remote -v //查看协议类型 git remote set-url origin url //设置远程协议 url为格式 https://github.com/someaccount/someproject.git //https格式 git@github.com:someaccount/someproject.git//git格式 npm(Node.js Package Manager) npm install -g hexo //安装hexo npm install //安装hexo依赖 npm install hexp-deployer-git --save //安装自动部署工具 hexo hexo -v //检查版本，查看安装状态 hexo init //初始化 hexo generate //编译 hexo server //开启本地预览服务 hexo clean //清除 hexo dployer //部署到远程仓库 建议 hexo文件夹中真正传到github只是public下生成的静态网页，所以除了io的博客页面仓库，建议github另外在建一个仓库用于管理博客的源文件，也方便移植，实际上只需要保存全局配置文件、source文件夹、theme文件夹就够了，具体保存哪些可参考hexo下的ignore文件。 源文件可以只保存md文件夹，用github关联，也可以保存整个hexo，这样写完一篇博客先 hexo d 更新网页之后之后再git commit源文件。 保存整个hexo包含主题。 备注 内容参考传送门 1.HEXO搭建个人博客 2.搭建个人博客-hexo+github详细完整步骤 3.使用hexo+github搭建免费个人博客详细教程[TOC] 4.github使用ssh密钥的好处与原因 5.hexo无法上传到github]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态权限申请]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F10%2F10%2FAndroid%2F%E5%9F%BA%E7%A1%80%2F%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0%E6%88%96%E8%80%85%E5%8F%98%E5%8C%96%2F%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7%2F</url>
    <content type="text"><![CDATA[Android 6.0及以上动态权限获取封装的工具类Why?Android6.0以前，对于权限的声明都是放在Mainfest文件中，安装应用时手机会根据清单文件中赋予应用相应权限。到了Android6.0，出于保护用户隐私的考虑，将所有权限分为普通权限（Normal Permission）与危险权限（Dangerous Permission），普通权限与以前一样只需要在清单文件中声明即可，危险权限需要请求用户允许. Detail不需要手动申请（Normal Permission） android.permission.ACCESS_LOCATION_EXTRA_COMMANDS android.permission.ACCESS_NETWORK_STATE android.permission.ACCESS_NOTIFICATION_POLICY android.permission.ACCESS_WIFI_STATE android.permission.ACCESS_WIMAX_STATE android.permission.BLUETOOTH android.permission.BLUETOOTH_ADMIN android.permission.BROADCAST_STICKY android.permission.CHANGE_NETWORK_STATE android.permission.CHANGE_WIFI_MULTICAST_STATE android.permission.CHANGE_WIFI_STATE android.permission.CHANGE_WIMAX_STATE android.permission.DISABLE_KEYGUARD android.permission.EXPAND_STATUS_BAR android.permission.FLASHLIGHT android.permission.GET_ACCOUNTS android.permission.GET_PACKAGE_SIZE android.permission.INTERNET android.permission.KILL_BACKGROUND_PROCESSES android.permission.MODIFY_AUDIO_SETTINGS android.permission.NFC android.permission.READ_SYNC_SETTINGS android.permission.READ_SYNC_STATS android.permission.RECEIVE_BOOT_COMPLETED android.permission.REORDER_TASKS android.permission.REQUEST_INSTALL_PACKAGES android.permission.SET_TIME_ZONE android.permission.SET_WALLPAPER android.permission.SET_WALLPAPER_HINTS android.permission.SUBSCRIBED_FEEDS_READ android.permission.TRANSMIT_IR android.permission.USE_FINGERPRINT android.permission.VIBRATE android.permission.WAKE_LOCK android.permission.WRITE_SYNC_SETTINGS com.android.alarm.permission.SET_ALARM com.android.launcher.permission.INSTALL_SHORTCUT com.android.launcher.permission.UNINSTALL_SHORTCUT 需要手动申请（Degerous Permission - 共9组27个）注： 假设一组中有一个被授予了，那么组内的也会默认被授予。 group:android.permission-group.CONTACTS permission:android.permission.WRITE_CONTACTS permission:android.permission.GET_ACCOUNTS permission:android.permission.READ_CONTACTS group:android.permission-group.PHONE permission:android.permission.READ_CALL_LOG permission:android.permission.READ_PHONE_STATE permission:android.permission.CALL_PHONE permission:android.permission.WRITE_CALL_LOG permission:android.permission.USE_SIP permission:android.permission.PROCESS_OUTGOING_CALLS permission:com.android.voicemail.permission.ADD_VOICEMAIL group:android.permission-group.CALENDAR permission:android.permission.READ_CALENDAR permission:android.permission.WRITE_CALENDAR group:android.permission-group.CAMERA permission:android.permission.CAMERA group:android.permission-group.SENSORS permission:android.permission.BODY_SENSORS group:android.permission-group.LOCATION permission:android.permission.ACCESS_FINE_LOCATION permission:android.permission.ACCESS_COARSE_LOCATION group:android.permission-group.STORAGE permission:android.permission.READ_EXTERNAL_STORAGE permission:android.permission.WRITE_EXTERNAL_STORAGE group:android.permission-group.MICROPHONE permission:android.permission.RECORD_AUDIO group:android.permission-group.SMS permission:android.permission.READ_SMS permission:android.permission.RECEIVE_WAP_PUSH permission:android.permission.RECEIVE_MMS permission:android.permission.RECEIVE_SMS permission:android.permission.SEND_SMS permission:android.permission.READ_CELL_BROADCASTS How to?检查是否获得权限public boolean checkPermisson(Context context, String permission) { if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) { //手机版本小于6.0的直接通过 VERSION_CODES-23 return true; } if (ContextCompat.checkSelfPermission(context, permission) == PackageManager.PERMISSION_GRANTED) { return true; } else if (ContextCompat.checkSelfPermission(context, permission) == PackageManager.PERMISSION_DENIED) { return false; } return false; } 单个权限申请public void requestSinglePermission(Activity activity, String permission, int requestCode) { if (ContextCompat.checkSelfPermission(activity, permission) != PackageManager.PERMISSION_GRANTED) { //提示为什么用户为什么要此权限，首次请求默认为false，第一次请求被拒绝后值为true，同意为false（同意后不进入请求） // 所以true要提示用户为什么要此权限 false是申请权限（用于第一次） //这个坑就是 ： 第一次请求权限 shouldshow值是false ，第二次及其以后shouldshow值是false值都为true ,所以弹出框会矛盾， // 处理方法是回调中再次判断如果没获得权限 弹出自己的提示对话框 可以选择进入应用权限设置 if (ActivityCompat.shouldShowRequestPermissionRationale(activity, permission)) { Log.i(&quot;shouldShow&quot;, &quot;-true&quot;); //true为第一次拒绝 大部分手机拒绝后不再弹出授权框, getRequestPermissionDialog(activity).show();//这里操作是手动打开本应用权限管理页面让用户自己去打开 } else { Log.i(&quot;shouldShow&quot;, &quot;-false&quot;); ActivityCompat.requestPermissions(activity, new String[]{permission}, requestCode); } } } 权限申请回调@Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == 1) { if (grantResults.length &gt; 0) { if (grantResults[0] == PackageManager.PERMISSION_GRANTED) { getImageFromCamera(null); } else if (grantResults[0] == PackageManager.PERMISSION_DENIED) { PermissionUtils.getInstance().getRequestPermissionDialog(this).show(); } } } } 跳转到应用设置 /** * desc: 跳转到应用的设置 */ private static void toAppDetailSetting(Context context) { //这里进行权限被拒绝的处理，就跳转到本应用的程序管理器 Toast.makeText(context, &quot;请在权限管理中开启定位权限&quot;, Toast.LENGTH_SHORT).show(); Intent i = new Intent(&quot;android.settings.APPLICATION_DETAILS_SETTINGS&quot;); String pkg = &quot;com.android.settings&quot;; String cls = &quot;com.android.settings.applications.InstalledAppDetails&quot;; i.setComponent(new ComponentName(pkg, cls)); i.setData(Uri.parse(&quot;package:&quot; + Constant.PACKAGE_NAME)); context.startActivity(i); } //有的手机打不开应用设置 private static void toAppDetailSetting(Context context) { //测试对象为小米 魅族 oppo/vivo 华为 三星 Intent intent = new Intent(); intent.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); Uri uri = Uri.fromParts(&quot;package&quot;, context.getPackageName(), null); intent.setData(uri); try { context.startActivity(intent); } catch (Exception e) { e.printStackTrace(); // 因为考虑到比如小米miui8和小米miui8之前的设置页面不一样会报错找不到类，如果其他手机也是这样要判断的内容太多 // 所以统一提示不做跳转让用户去手机管家手动设置，如果需要跳转则需要找到对应手机平台的手机管家页面 Toast.makeText(context, &quot;跳转应用权限管理失败，请手动打开\&quot;手机管家\&quot;-\&quot;权限管理\&quot;-\&quot;应用权限管理\&quot;打开所需权限&quot;, Toast.LENGTH_LONG).show(); } } 多组权限申请其实和申请一个权限是一样的，只是String[] permissions 里的权限个数多，然后在回调里面判断每一个权限是否都是被授权 /** * desc: 请求一组权限 */ public static void requestManyPremisson(Activity activity, String[] permissions, int requestCode) { ActivityCompat.requestPermissions(activity, permissions, requestCode); } Summary 权限申请的大坑：shouldShowRequestPermissionRationale此方法的作用是判断是否应该给用户展示请求此权限的原因，首次请求默认为false，第一次请求被拒绝后值为true，同意为false（同意后不进入请求），因为返回值变化不能做常规的选择分支，处理方法是将展示框放到回调中，再次判断如果没获得权限，弹出自己的提示对话框，然后选择进入设置中的应用权限设置。 应用权限申请被拒绝后，要能弹出对话框，使用户选择跳到应用权限设置界面手动设置。 Tips 权限申请尽量不要一次性全部申请完，最好是在需要的时候进行判断,只请求你需要的权限，减少请求的次数,在应用启动的时候，最好先请求应用必须的一些权限，非必须权限在使用的时候才请求 进行版本的判断，如果小于Android 6.0的可以不用考虑权限问题 申请一组中的任意一个权限Android系统会给予应用整个组的所有权限。但是在Android O已经修复此项，系统只会授予应用明确请求的权限，不再分配整组,所以建议还是在该需要什么权限的地方全加上判断，不要再用组来区分。 API&amp;常量 ContextCompat.checkSelfPermission(Context context,String Permission) ActivityCompat.requestPermissions(Activity activity,String permission,int requestCode) ActivityCompat.shouldShowRequestPermissionRationale(Activity activity,String permission) PackageManager.PERMISSION_GRANTED PackageManager.PERMISSION_DENIED Postscripts 由于目前市面上手机大部分带有自带的手机管家，在跳转到应用设置界面不一定能成功跳转，需要查阅对应手机的API。目前是简易做法仅供参考：try catch包裹 提示用户自己去手机管家打开权限(XD) 异常]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>适配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PopupWindow与Dialog]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F10%2F10%2FAndroid%2FUI%2Fwidget%2Fnative%2FPopupWindow%E4%B8%8EDialog%2F</url>
    <content type="text"><![CDATA[概述 Android弹窗主要是两种：Popupwindow和Dialog，区别以及使用场合： 1、Alertdialog 设置位置没有popupwindow灵活 2、Alertdialog设置满宽度没有popupwindow简单，总有内边距 Dialog普通dialogAlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setTitle(&quot;单按钮&quot;); builder.setMessage(&quot;这里是消息块&quot;); builder.setNeutralButton(&quot;中间&quot;,null); builder.setPositiveButton(&quot;确定&quot;,null); builder.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { dialog.dismiss(); } }); //builder设置,按返回键和触摸外区域都不消失 //builder.setCancelable(false); //获得dialog实体 //AlertDialog dialog = builder.create(); //-alertdialog设置,返回键和外区域都不消失 //dialog.setCancelable(false); //-alertdialog设置 返回键可以消失,点击外区域不消失 //dialog.setCanceledOnTouchOutside(false); //dialog.show();//dialog 改属性了记得不要用build.show() //修改按钮字体颜色：*/ //addBookcaseDialog.getWindow().setBackgroundDrawableResource(R.drawable.shape_bg_dialog_ios);//设置弹出框的背景 builder.show(); 列表dialogString[] items = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;}; AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setTitle(&quot;列表&quot;); builder.setItems(items, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { Toast.makeText(builder.getContext(), &quot;&quot; + which, Toast.LENGTH_SHORT).show(); } }); builder.show(); 单选dialogString[] items = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;}; AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setTitle(&quot;单选项&quot;); //不要设置message块 设置了没有单选、多选、列表 builder.setSingleChoiceItems(items, 0, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { Toast.makeText(builder.getContext(), &quot;&quot; + which, Toast.LENGTH_SHORT).show(); } }); builder.setPositiveButton(&quot;确定&quot;, null); builder.show(); 多选dialogString[] items = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;}; boolean[] choose = {false, false, false}; AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); builder.setTitle(&quot;多选&quot;);//不要设置message builder.setMultiChoiceItems(items, choose, new DialogInterface.OnMultiChoiceClickListener() { @Override public void onClick(DialogInterface dialog, int which, boolean isChecked) { if (isChecked) { Toast.makeText(builder.getContext(), &quot;&quot; + isChecked, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(builder.getContext(), &quot;&quot; + isChecked, Toast.LENGTH_SHORT).show(); } } }); builder.show(); 自定义布局 &amp;宽高设置AlertDialog.Builder builder = new AlertDialog.Builder(MainActivity.this); AlertDialog dialog = builder.create(); dialog.setTitle(&quot;自定义布局&quot;); dialog.setView(LayoutInflater.from(builder.getContext()).inflate(R.layout.view_dialog, null));//不影响message //宽高设置 Window dialogWindow = dialog.getWindow(); DisplayMetrics metrics = new DisplayMetrics(); getWindowManager().getDefaultDisplay().getMetrics(metrics); WindowManager.LayoutParams params = dialogWindow.getAttributes(); //ps：即时布局文件设置全屏,dialog还是有系统自带的10dp内边距 params.width = metrics.widthPixels; params.height = metrics.heightPixels; //位置设置 dialogWindow.setGravity(Gravity.LEFT | Gravity.TOP); params.x = 50; // X偏移 params.y = 150; // Y偏移 dialogWindow.setAttributes(params); dialog.show(); 全屏设置方式一1.添加style &lt;!-- 全屏style --&gt; &lt;style name=&quot;MyFullScreenDialog&quot; parent=&quot;android:Theme.Dialog&quot;&gt; &lt;!--标题 --&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;!-- 彻底全屏 不留系统状态栏 --&gt; &lt;!--&lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;--&gt; &lt;/style&gt; 2.自定义dialog public class FullScreenDialog extends AlertDialog { protected FullScreenDialog(@NonNull Context context) { super(context, R.style.MyFullScreenDialog); } protected FullScreenDialog(@NonNull Context context, @StyleRes int themeResId) { super(context, themeResId); } protected FullScreenDialog(@NonNull Context context, boolean cancelable, @Nullable OnCancelListener cancelListener) { super(context, cancelable, cancelListener); } @Override public void show() { super.show(); /** * 设置宽度全屏，要设置在show的后面 */ WindowManager.LayoutParams layoutParams = getWindow().getAttributes(); layoutParams.gravity = Gravity.BOTTOM; layoutParams.width = WindowManager.LayoutParams.MATCH_PARENT; layoutParams.height = WindowManager.LayoutParams.MATCH_PARENT; getWindow().getDecorView().setPadding(0, 0, 0, 0); getWindow().setAttributes(layoutParams); //todo:quesstion:这样的满屏是没有系统的状态栏， 能不能直接修改原有的dialogstyle中的四个padding属性值来达到保留状态栏的全屏（除了设置y的偏移） } 3.代码中使用 FullScreenDialog dialog = new FullScreenDialog(MainActivity.this); View view = LayoutInflater.from(MainActivity.this).inflate(R.layout.view_dialog, null); //dialog.setTitle(&quot;111111111111111111&quot;); //dialog.setMessage(&quot;22222222222222222&quot;);//无效 移步写在布局文件中 dialog.show(); dialog.setContentView(view);//要放在show后面 方式二 (优：只设置宽全屏的情况)AlertDialog.Builder builder = new AlertDialog.Builder(context); //builder.setTitle(&quot;ddddd&quot;); AlertDialog dialog = builder.create(); dialog.setView(view);//view根布局设置一个背景色 dialog.getWindow().setGravity(Gravity.BOTTOM); //dialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);//弹出输入法 dialog.show(); WindowManager.LayoutParams params = dialog.getWindow().getAttributes(); params.width = WindowManager.LayoutParams.MATCH_PARENT; dialog.getWindow().getDecorView().setPadding(0,0,0,0); dialog.getWindow().setAttributes(params); 方式三(对话框在底部，含编辑+输入法弹出的较好的实现方式)AlertDialog.Builder builder = new AlertDialog.Builder(context, R.style.FullScreenDialog);//这个主题是之前的全屏主题 modifyDialog.setView(view); modifyDialog.getWindow().setGravity(Gravity.BOTTOM); modifyDialog.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE); modifyDialog.setCanceledOnTouchOutside(false); dialog.show(); //设置宽全屏 WindowManager.LayoutParams params = dialog.getWindow().getAttributes(); params.width = WindowManager.LayoutParams.MATCH_PARENT; dialog.getWindow().getDecorView().setPadding(0, 0, 0, 0); dialog.getWindow().setAttributes(params); InputMethodManager imm = (InputMethodManager) getActivity().getSystemService(Context.INPUT_METHOD_SERVICE); imm.toggleSoftInput(InputMethodManager.SHOW_IMPLICIT, InputMethodManager.HIDE_NOT_ALWAYS); //开关输入法 扩展1.修改按钮颜色： 5.0以上修改AppTheme下colorAccent属性 2.偏移的数值为负数代表的是反方向偏移，如x:left的-50是right的50效果 3.如果自定义布局的dialog没有match_parent，需要在根布局下再加一个容器均设置match_parent 4.Dialog的位置和大小与加载的布局文件无关。需自己设置dialog参数。 PopupWindow使用PopupWindow popupWindow = new PopupWindow(MainActivity.this); View view = LayoutInflater.from(MainActivity.this).inflate(R.layout.view_pop, null); popupWindow.setContentView(view); popupWindow.setWidth(ViewGroup.LayoutParams.WRAP_CONTENT);//必须设置宽高，避免不显示 popupWindow.setHeight(ViewGroup.LayoutParams.WRAP_CONTENT); popupWindow.setFocusable(true);//为布局内有edittext等需要焦点的控件 popupWindow.setOutsideTouchable(true);//点击外部以及返回消失 popupWindow.setBackgroundDrawable(new BitmapDrawable());//设置此项outside才生效,废弃用new // PaintDrawable() //popupWindow.setAnimationStyle(R.style.popAnimation);//设置动画 popupWindow.setOnDismissListener(new PopupWindow.OnDismissListener() { @Override public void onDismiss() { backgroundAlpha(1f); } }); backgroundAlpha(0.5f);//背景变暗 popupWindow.showAsDropDown(pop1);//控件下方 //popupWindow.showAsDropDown(pop1,150,0);//控件下方带偏移位置 //popupWindow.showAtLocation(rootView,Gravity.CENTER,0,0);//父控件（页面）位置,含偏移位置]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>dialog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git错误记录]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F10%2F09%2FGit%2FGit%2Fgit%E9%97%AE%E9%A2%98%E5%92%8C%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Git错误记录1.Unable to create ‘E:/xxx/.git/index.lock’: File exists提交日志未完成的错误：在执行commit的时候出的错，由于指令错误，比如未add直接提交，进入commit提交日志界面没写，然后退出就出此错误（ps:提交日志真花眼）解决方案：在git目录把index.lock文件删除，或者直接执行 rm-f .git/index.lock 新建项目push失败 1.执行git push origin main 出现”Everything up-to-date” 2.执行git push 登录的时候密码都对却提示Logon failed, use ctrl+c to cancel basic credential prompt. 试了很多办法都推送不到远程，开始还以为是github新项目默认分支变成了main的原因，后来发现是commit的时候没有添加信息，所以导致实际上 原因： 1）没有git add . 2）没有git commit -m &quot;提交信息&quot; 查看gitlog日志中文描述是乱码 1、gitbash窗口右键 -&gt; options -&gt; Text -&gt;locale选择zh_CN,character选择UTF-8 2、运行 git config --global i18n.commitencoding utf-8 //提交命令的时候使用utf-8编码集提交 git config --global i18n.logoutputencoding utf-8 //该日志输出时使用utf-8编码集显示 export LESSCHARSET=utf-8 //设置LESS字符集为utf-8 设置好上面两部log查阅就是中文了 换行符警告warning: LF will be replaced by CRLF in 解决办法原因是需要提交的文件是在windows下省城的，windows中的换行符为CRLF，linux下的换行符为LF解决办法 git config --global core.autocrlf false 再执行git提交]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git(二) 进阶使用]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F10%2F08%2FGit%2FGit%2FGit%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[标签作用：为某次提交打上一个标记，便于清楚此次提交最主要的作用。一般用来发线上包的时候打版本代码的标记。标签可以添加多个。 查看所有标签: git branch -r 创建标签： 打上当前标签： git tag -a 标签名字 -m &quot;标签概要&quot; 为某次提交打上标签，后期加注标签： git tag -a 标签名字 版本校验和(或前几位字符) -m &quot;标签概要&quot; 注意：1、 -m后面是标签的解释说明，不是版本的名字 2、创建标签的只是在上一次提交上打标签，即当前本地版本状态上的标签，不受未改动的代码影响，所以打标签之前先提交 删除标签： 先删除本地标签： git tag -d 标签名 然后推送到远程仓库： git push origin --delete 标签名 查看所有标签： git tag 推送标签：标签创建之后只是在本地仓库，默认情况下代码推送不会推送标签，需要单独推送标签服务器才能记录 推送单个标签: git push origin 标签名 推送所有标签： git push origin --tags 给以前的（指定的）提交记录打上标签： git tag -a &quot;标签名&quot; commitID -m &quot;标签信息&quot; ps:studio中可以对某次提交直接加标签 分支分支是git很强大的功能，可以进行多人合作和多模块分开进行。分支切换则文件会恢复到切换的分支保存时候的状态。 新建分支 git branch 新分支名 ps:尽量不要用中文命名 查看所有分支/当前分支 git branch 分支切换:默认需要提交之后才能切换 git checkout 分支名 创建新分支并切换 git checkout -b 新分支名 删除本地分支： git branch -d 分支名 没合并用大写的D 删除远程git服务器上的分支： git push origin -d BranchName 分支合并 重新配置ignore一、取消所有文件的跟踪 git rm -r --cached 二、更新ignore 三、重新跟踪所有文件 git add . git commit stash 保存和恢复工作进度stash命令可以用于临时保存和提取修改过的代码，最常见的就是正在开发的时候测试需要打个包，可以暂存起来打包之后再放出注意：要未add之前才能执行stash，如果add了 那就要取消文件追踪 git stash //保存 git stash [save message] //保存，save为可选项，message为本次保存的注释 git stash pop //恢复上次的保存 git stash pop stash@{num} //恢复，num是可选项，通过git stash list可查看具体值。只能恢复一次 git stash apply stash@{num} 恢复，num是可选项，通过git stash list可查看具体值。可回复多次 git stash list //所有保存的记录列表 git stash drop stash@{num} 删除某个保存，num是可选项，通过git stash list可查看具体值 git stash clear 删除所有保存 参考标签参考 分支参考 Git如何在不提交当前分支的情况下切换到其它分支进行操作]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 版本]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F09%2F18%2FAndroid%2F%E5%9F%BA%E7%A1%80%2F%E7%B3%BB%E7%BB%9F%E6%9B%B4%E6%96%B0%E6%88%96%E8%80%85%E5%8F%98%E5%8C%96%2FAndroid-%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[Android 历史版本 （只记录4.0以上）版本 版本名称 API/SDK_INT Android 4.0-4.4 4.0 - 4.0.2 Ice Cream Sandwich 14 4.0.3 - 4.0.4 Ice Cream Sandwich 15 4.1 Jelly Bean 16 4.2 Jelly Bean 17 4.3 Jelly Bean 18 4.4 KitKat 19 4.4W W 20 Android L (5.0) 5.0 Lollipop 21 5.1 Lollipop 22 Android M (6.0) 6.0 Marshmallow 23 Android N (7.0) 7.0 Nougat 24 7.1 Nougat 25 Android O (8.0) 8.0 Oreo 26 8.1 Oreo 27 Android P (9.0) 9.0 Pie 28]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>版本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[禁用多点触控]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F09%2F06%2FAndroid%2F%E5%9F%BA%E7%A1%80%2F%E6%89%8B%E5%8A%BF%2F%E7%A6%81%E7%94%A8%E5%A4%9A%E7%82%B9%E8%A7%A6%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[如何禁用多点触控最近测试自从发现了双指操控发现了bug之后似乎乐于其中找出了一堆关于多点同时触控的bug，于是观察了项目之后发现其实只有部分地方可能需要用到多指的操作，于是想干脆关闭多点操控，整理下查阅的资料。 在默认情况下，Android是支持多点触控的 全局禁用一说到全局，那肯定是和theme有关 自定义theme并在application标签中引用 &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; 。。。 &lt;!--全局禁止多点触控 --&gt; &lt;item name=&quot;android:windowEnableSplitTouch&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;android:splitMotionEvents&quot;&gt;false&lt;/item&gt; 。。。 &lt;/style&gt; 局部禁用在布局文件添加android:splitMotionEvents属性 android:splitMotionEvents=&quot;false&quot;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>手势</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发（四）- 插件整理]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F09%2F05%2FAndroid%2F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2FAndroid%E5%BC%80%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Android Studio 插件整理（多方收集，持续更新~)插件安装：setting&gt;plugins&gt;Browse Repositories 开发工具插件1.Android Parcelable code generator快捷实现parcelable代码，可直接插入 2.GsonFormat操作：Alt+insert打开插件列表或者直接Alt+s可根据json数据快速生成bean类 3.ButterKnife几个插件3.1Android ButterKnife Zelezny配合butterknife使用快速注解 3.2RemoveButterKnife移除butterknife代码当我们有一些代码需要拿到其他项目使用，如果不能使用butterknife，这时候，我们需要从注解改回findviewbyid 3.Android-ButterKnife-Plugin-Plus1、自由选择是否在当前类中对ButterKnife进行初始化，避免了原版本只要使用插件初始化控件会自动在onCreate中进行ButterKnife.bind(this)的尴尬。在基类中进行ButterKnife的初始化，不必要每个类中都要初始化，对开发框架的搭建更加方便。 2、在Android Studio的设置界面，对在当前类中是否强制初始化提供了默认值设置，这样就可以让插件使用更符合自己的操作习惯。 4.GradleDependenciesHelperPluginmaven gradle 依赖支持自动补全 5.JsonOnlineViewer在Android Studio中请求、调试接口 6.AndroidProguardPlugin键生成项目混淆代码插件,部分第三方项目的混淆还未添加完全 7..ignoregit 配置.ignore文件插件 8.PermissionsDispatcher plugin自动生成6.0权限的代码 9.SingletonTest快速生成单例模式的预设 10.jRebel For Android不仅能够做到UI布局的实时预览，它甚至做到了让你更改java代码后就能实时替换apk中的类文件，达到应用实时刷新，官网的介绍是：Skip build, install and run，因此它可以节约我们很多很多的时间，它的效果也十分不错。 11.android-strings-search-plugin通过输入文字找到strings.xml资源的插件 调试插件12.genymotion配合genymotion模拟器 13.ADB WIFI使用wifi无线调试你的app，无需root权限也可参考以下文章：Android wifi无线调试App新玩法ADB WIFI 14.AndroidWiFiADB无线调试应用 15.LeakCanary在开发阶段检测出内存泄露的问题使用说明 16.smalismali代码调试插件 界面&amp;风格&amp;个性化插件16.CodeGlance在右边可以预览代码，实现快速定位 17.Android Resource Usage Count统计资源文件中每个标签被引用的次数 18.folding-plugin对布局文件进行分组 19.Material Theme UI添加Material主题 20.CheckStyle-IDEACheckStyle-IDEA 是一个检查代码风格的插件，比如像命名约定，Javadoc，类设计等方面进行代码规范和风格的检查，你们可以遵从像Google Oracle 的Java 代码指南 ，当然也可以按照自己的规则来设置配置文件，从而有效约束你自己更好地遵循代码编写规范。 21.LayoutFormatterdrakeet 开发一个一键格式化你的 XML 文件的 Android Studio 插件，至于为什么不用 Android Studio 自带的格式化功能而用这个插件，可以看下作者的一篇 Blog -&gt; 当我们谈 XML 布局文件代码的优雅性 22.Lifecycle Sorter可以根据Activity或者fragment的生命周期对其生命周期方法位置进行先后排序，快捷键Ctrl + alt + K 其他拓展插件23.MVPHelper一款Intellj IDEA 和Android Studio的插件，可以为MVP生成接口以及实现类，解放双手。具体请查看Android Studio插件之MVPHelper，一键生成MVP代码一文 1 24.Matchmaker专为微信小程序开发的插件，目前可在 IntelliJ IDEA 中使用。它可以帮你完成重复机械无趣麻烦的绑定方法的过程，自动的将需要新建的方法注入到 js 文件中去。 25.ECTranslation翻译插件,可以将英文翻译为中文： 26.AndroidSourceViewer在线查看 Android 和 Java 指定版本源码: -]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多渠道打包]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F09%2F04%2FAndroid%2F%E4%B8%8A%E7%BA%BF%2F%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[多渠道包(channel)什么是多渠道包多渠道打包是给apk打包的时候加一个标识，根据标识的个数打对应的多个apk包出来，一般标识就是市场的名字，对应的市场放置对应的渠道包，方便对不同市场的统计。这里只记录关于友盟的多渠道打包相关配置 友盟多渠道打包Manifest： &lt;meta-data android:name=&quot;UMENG_APPKEY&quot; android:value=&quot;xxxxx...&quot; /&gt; &lt;meta-data android:name=&quot;UMENG_CHANNEL&quot; android:value=&quot;${UMENG_CHANNEL_VALUE}&quot; /&gt; build.gradle： /*配置渠道*/ productFlavors.all { flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name] } productFlavors { seeknature {} yingyongbao {} debug_test {} //测试包 } 错误友盟配置多渠道后的报错：All flavors must now belong to a named flavor dimension. Learn more at https://d.android.com， 解决方式：在defaultConfig{}中添加：flavorDimensions &quot;&quot; 最好在属性里面加入 default，默认 defaultConfig { applicationId &quot;xxx&quot; minSdkVersion 18 targetSdkVersion 27 versionCode 1 versionName &quot;1.1.9&quot; ... flavorDimensions &quot;default&quot; ... } 参考1 参考2]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>上线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码混淆]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F09%2F04%2FAndroid%2F%E4%B8%8A%E7%BA%BF%2F%E5%AE%89%E5%85%A8%2F%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%2F</url>
    <content type="text"><![CDATA[代码混淆混淆的作用如何混淆混淆很简单，主要分为2个步骤，首先开启代码混淆，然后写混淆规则即可 1、开启混淆 buildTypes { debug { ... } release { zipAlignEnabled true //资源按4字节对齐 minifyEnabled true //最小化资源包,开启混淆 shrinkResources true//去掉不用资源 proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; //混淆文件 signingConfig signingConfigs.release } } 2、混淆规则，通用的模板,添加至proguard-rule.pro文件中修改定制化区域即可，github例子： #-------------------------------------------基本不用动区域------------------------------------------- #---------------------------------基本指令区---------------------------------- #指定压缩级别,在0~7之间，默认为5，一般不做修改 -optimizationpasses 5 #不跳过非公共的库的类成员 -dontskipnonpubliclibraryclassmembers #混淆前后代码的对照表 -printmapping proguardMapping.txt #混淆时采用的算法 -optimizations !code/simplification/cast,!field/*,!class/merging/* #-ignorewarnings # 抑制警告 -keepattributes *Annotation*,InnerClasses #-dontoptimize -keepattributes Signature #保留行号 -keepattributes SourceFile,LineNumberTable -keepattributes EnclosingMetho #---------------------------------------------------------------------------- #---------------------------------默认保留区--------------------------------- # 保留我们使用的四大组件，自定义的Application等等这些类不被混淆 # 因为这些子类都有可能被外部调用 -keep public class * extends android.app.Activity -keep public class * extends android.app.Application -keep public class * extends android.app.Service -keep public class * extends android.content.BroadcastReceiver -keep public class * extends android.content.ContentProvider -keep public class * extends android.app.backup.BackupAgentHelper -keep public class * extends android.preference.Preference -keep public class * extends android.view.View -keep public class com.android.vending.licensing.ILicensingService # 保留support下的所有类及其内部类 -keep class android.support.** {*;} # 保留继承的 -keep public class * extends android.support.v4.** -keep public class * extends android.support.v7.** -keep public class * extends android.support.annotation.** # 保留我们自定义控件（继承自View）不被混淆 -keep public class * extends android.view.View{ *** get*(); void set*(***); public &lt;init&gt;(android.content.Context); public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int); } # 保留枚举类不被混淆 -keepclassmembers enum * { public static **[] values(); public static ** valueOf(java.lang.String); } -keepclasseswithmembers class * { public &lt;init&gt;(android.content.Context, android.util.AttributeSet); public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int); } # 保留Parcelable序列化类不被混淆 -keep class * implements android.os.Parcelable { public static final android.os.Parcelable$Creator *; } # 保留Serializable序列化的类不被混淆 -keepclassmembers class * implements java.io.Serializable { static final long serialVersionUID; private static final java.io.ObjectStreamField[] serialPersistentFields; private void writeObject(java.io.ObjectOutputStream); private void readObject(java.io.ObjectInputStream); java.lang.Object writeReplace(); java.lang.Object readResolve(); } # 保留R下面的资源 -keep class **.R$* { *; } # 保留本地native方法不被混淆 -keepclasseswithmembernames class * { native &lt;methods&gt;; } # 对于带有回调函数的onXXEvent、**On*Listener的，不能被混淆 -keepclassmembers class * { void *(**On*Event); } #---------------------------------------------------------------------------- #---------------------------------webview------------------------------------ # webView处理，项目中没有使用到webView忽略即可 -keepclassmembers class fqcn.of.javascript.interface.for.Webview { public *; } -keepclassmembers class * extends android.webkit.WebViewClient { public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap); public boolean *(android.webkit.WebView, java.lang.String); } -keepclassmembers class * extends android.webkit.WebViewClient { public void *(android.webkit.WebView, jav.lang.String); } #---------------------------------------------------------------------------- #-------------------------------------------定制化区域---------------------------------------------- #---------------------------------1.实体类--------------------------------- #------------------------------------------------------------------------- #---------------------------------2.第三方包------------------------------- #------------------------------------------------------------------------- #---------------------------------3.与js互相调用的类------------------------ #------------------------------------------------------------------------- #---------------------------------4.反射相关的类和方法----------------------- #---------------------------------------------------------------------------- #--------------------------------------------------------------------------------------------------- 反编译&amp;检测混淆1、准备工具： apktool （资源文件获取） : 下载地址 dex2jar（源码文件获取）:下载地址 jd-gui （源码查看）:下载地址 2、反编译流程:资源文件：将apk的后缀改为rar打开即可代码： 1、将apk后缀改为rar打开获取classes.dex文件 2、将classes.dex文件放于解压出来的工具【dex2jar-2.0】文件夹内 3、cmd定位到【dex2jar-2.0】文件夹目录执行指令： d2j-dex2jar classes.dex 得到classes-得闲jar.jar文件 4、运行jd-gui.exe工具，将上面得到的jar文件拖进即可查看源码 错误开启混淆时报错：Unable to resolve dependency for ‘:app@debug/compileClasspath’gradle升到4.4后报的错误，解决办法： 1、所有的依赖包从compile改成implementation 2、打开shadowsocks，把http proxy的代理指向本地。 !(https://img-blog.csdn.net/20180408103712179) 再次build，OK。 3、如果还不行就开启离线模式(offline work) 原因是：网被墙 打包时混淆出错：proguard.ParseException Unexpected keyword仔细查看混淆文件proguard-rules.pro的拼写 1,检查关键字是否错误，keep class 等 2,检查包名是否拼写错误 3,检查是否有中文字符，比如括号，点，空格，空格，空格]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>andorid安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome实用插件]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F09%2F01%2FAndroid%2F%E8%A7%84%E8%8C%83%E5%92%8C%E6%9B%B4%E5%A4%9A%E4%BD%BF%E7%94%A8%2FChrome%E5%AE%9E%E7%94%A8%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[推荐收藏的Chrome插件(部分链接需要翻墙)工具类-广告屏蔽：Advertising Terminator-Octotree Chrome:github查看项目时可以清晰明了的看到项目的结构以及具体代码，使下载代码更具有目的性，减少不必要代码的下载，而且看起来更清楚。安装完成后打开插件找页面左上角有个按钮。 学习类 英语学习：Grammarly 休闲类 听歌：Listen1包含了网易云音乐，虾米，QQ音乐的曲库 网址 插件网 ps: 直接将crx文件拖放到chrome时提示“无法添加,则先打开扩展程序“界面再拖动到这里。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Monkey Test]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F08%2F31%2FAndroid%2F%E4%B8%8A%E7%BA%BF%2F%E6%B5%8B%E8%AF%95%2FMonkey-Test%2F</url>
    <content type="text"><![CDATA[Monkey Test什么是Monkey Test一、顾名思义，Monkey就是猴子， Monkey测试，就像一只猴子， 在电脑面前，乱敲键盘在测试。 猴子什么都不懂， 只知道乱敲。通过Monkey程序模拟用户触摸屏幕、滑动Trackball、 按键等操作来对设备上的程序进行压力测试，检测程序多久的时间会发生异常。Monkey是Android中的一个命令行工具，可以运行在模拟器里或者现实设备中，向系统发送伪随机的用户事件流（点击、滑动、Application切换、横竖屏、应用关闭）实现对正在开发的应用程序进行压力测试。monkey测试是一种为了测试软件的稳定性，健壮性的快速有效的方法。只针对Activity做测试，不能对Service做测试。 二、质量要求：版本release（发布）前，Monkey跑出来的结果中crash要为0，final release前，Monkey跑完的总次数应为25W，结果里不允许有nullPointException出现 快速使用monkey测试工具在Android原生系统和sdk中都有，sdk中位于platform-tools文件夹下，快速使用 1、确认手机已经连接上调试 2、cmd，找到sdk下的platform-tools，定位到adb //2.1、进入到adb shell //第二步是进入monkey 可以查看monkey指令 3、执行monkey命令 adb shell monkey -p 包名 -s 500 --ignore-crashes --ignore-timeouts --monitor-native-crashes -v -v -v 10000&gt; F:\apppulish\monkeytest.txt 语句表示：seek值为500测试包名的应用10000次忽略报错，日志导出到f盘目录下 4、实际操作： 设置好此次测试seek值，首先为保证测试数量的完整进行,跑一次全忽略崩溃、超时、异常获得所有项目所有测试有问题的地方，等（开发）解决之后再跑不忽略的设置同样的seek值看bug是否全部修改完成 基本指令,参考-p 用此参数指定一个或者多个包 -v 用于指定反馈的信息级别（日志的详细程度），分为三个级别 -s 指定伪随机数生成器的seed值，如果seed相同，则两次monkey 测试产生的事件序列也相同。 --throttle 制定每个事件结束后的间隔时间，降低系统压力。（如果不指定系统会尽快的发送事件序列） bug分析与解决http://www.bubuko.com/infodetail-1504012.html 异常1、类似小米开启monkey快速跑完的情况：Injecting to another application requires INJECT_EVENTS permission 解决：开启模拟点击权限 解决方案：打开USB调试（安全设置） 再调试，设置 --》 更多设置 --》 开发者选项 --》USB调试（安全设置） 参考：https://blog.csdn.net/zhaoqi5705/article/details/53455597 参考 参考1 参考2 参考3]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回调到主线程的方法]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F08%2F17%2FAndroid%2F%E5%9F%BA%E7%A1%80%2F%E7%BA%BF%E7%A8%8B%26%E5%BC%82%E6%AD%A5%2F%E5%9B%9E%E8%B0%83%E5%88%B0%E4%B8%BB%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Android中回调到主线程的方法方法一：view.post（Runnable action）view.post（new Runnable{ textview.setText（&quot;更新textview&quot;）; }） 方法二： activity.runOnUIThread（Runnable action）public viod updateUI(final Context context){ @Override public void run(){ //主线程中 } } 方法三：Handler机制定义Handler必须要在主线程中定义才能操作主线程，如果想在其他地方定义声明时要这样写Handler mainHandler = new Handler(Looper.getMainLooper()) Handler handelr = new Handler(Looper.getMainLooper()); handler.post(new Runnable(){ @Overrude public void run(){ //doing something } }) 方法四：AsyncTaskdoInBackground方法是在子线程中，所以，我们在这个方法里面执行耗时操作。同时，由于其返回结果会传递到onPostExecute方法中，而onPostExecute方法工作在UI线程，这样我们就在这个方法里面更新ui，达到了异步更新ui的目的。 /** *该类中方法的执行顺序依次为：onPreExecute, doInBackground, onPostExecute */ private class MyAsyncTask extends AsyncTask&lt;String, Integer, String&gt; { /** * 主线程中执行 * 在execute()被调用后首先执行 * 一般用来在执行后台任务前对UI做一些标记 */ @Override protected void onPreExecute() { super.onPreExecute(); System.out.println(&quot;MyAsyncTask.onPreExecute&quot;); } /** * 子线程中执行，执行一些耗时操作，关键方法 * 在执行过程中可以调用publishProgress(Progress... values)来更新进度信息。 */ @Override protected String doInBackground(String... params) { System.out.println(&quot;MyAsyncTask.doInBackground&quot;); //只是模拟了耗时操作 int count = 0; for (int i = 0; i &lt; 10; i++) { try { count++; publishProgress((count % 100) * 10); Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } } // publishProgress((int) ((count / (float) total) * 100)); return &quot;耗时操作执行完毕&quot;; } /** * 主线程中执行 * 在调用publishProgress(Progress... values)时，此方法被执行，直接将进度信息更新到UI组件中 */ @Override protected void onProgressUpdate(Integer... values) { super.onProgressUpdate(values); progressBar.setProgress(values[0]); textView.setText(&quot;loading...&quot; + values[0] + &quot;%&quot;); System.out.println(&quot;MyAsyncTask.onProgressUpdate&quot;); } /** * 在主线程中，当后台操作结束时，此方法将会被调用 * 计算结果将做为参数传递到此方法中，直接将结果显示到UI组件上。 */ @Override protected void onPostExecute(String aVoid) { super.onPostExecute(aVoid); System.out.println(&quot;MyAsyncTask.onPostExecute aVoid=&quot; + aVoid); textView.setText(aVoid); } /** * 主线程中执行 * 当异步任务取消后的，会回调该函数。在该方法内可以更新UI */ @Override protected void onCancelled() { super.onCancelled(); System.out.println(&quot;MyAsyncTask.onCancelled&quot;); progressBar.setProgress(0); textView.setText(&quot;0&quot;); } @Override protected void onCancelled(String s) { super.onCancelled(s); } } 参考资料]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[上市场相关]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F08%2F02%2FAndroid%2F%E4%B8%8A%E7%BA%BF%2F%E4%B8%8A%E5%B8%82%E5%9C%BA%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[打包关于上传至第三方市场时，需要使用到appid相关的需要签名的东西 签名jks文件与keystore的区别jks是在studio里面生成的签名证书, keystore是eclipse里面生成的. 项目中引用的是sore文件的区别和怎么设置引用 signingConfigs .jks文件添加到build.gradle中 获得签名的方法：1、命令方法 2、apk方法 Android如何签名 获取MD5、SHA1、SHA-256签名 studio中: 找到右侧的gradle-&gt;app-&gt;android-&gt;signingReport运行即可得到 使用keytool工具(要有jks和知道密码: 通过命令行进入到签名文件目录下 然后键入keytool -list -v -keystore 签名文件（xxx.keystore或者xxx.jks）]]></content>
  </entry>
  <entry>
    <title><![CDATA[activity界面的一些操作]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F07%2F25%2FAndroid%2FUI%2Factivity%E7%95%8C%E9%9D%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Activity相关全屏设置1、代码中： 位置在设置contentview之前： super.create(saveInstanceState); this.requesWindowFeature(Window.FEATRUE_NO_TITLE); this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN); setContentView(R.layout.xxxx); 2、AndroidMenifest文件中： &lt;activity android:name= &quot;.MainActivity&quot; android:theme= &quot;@android:style/Theme.NotitleBar.Fullscreen&quot; &lt;intnet - filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name = &quot;android:intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 3、设置整个应用所有页面为全屏，直接将theme属性添加到application标签中： &lt;application android:icon=&quot;@drawable/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot; @android :style/Theme.NoTitleBar.Fullscreen&quot;&gt; ... 4.要讲某个页面设置为全屏，需要另外写一个集成与theme中的主题去设置 &lt;... android:theme=&quot;@style/AppTheme&quot; ...&gt; &lt;style name=&quot;AppTheme2&quot; parent=&quot;AppTheme&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; &lt;/style&gt; 跳转动画1、使用overridePendingTransition方法 Intent intent = new Intent(MainActivity.this, SecondActivity.class); startActivity(intent); //第一个是需要打开的动画，第二个参数是需要关闭的动画 activity.overridePendingTransition(R.anim.slide_in_left,R.anim.slide_in_left); 2、使用style定义切换动画 &lt;application ... Android:theme=&quot;@style/AppTheme&quot; ...&gt; &lt;!-- Base application theme. --&gt; &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.DarkActionBar&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt; &lt;item name=&quot;Android:windowAnimationStyle&quot;&gt;@style/activityAnim&lt;/item&gt; &lt;/style&gt; &lt;!-- 使用style方式定义activity切换动画 --&gt; &lt;style name=&quot;activityAnim&quot;&gt; &lt;item name=&quot;Android:activityOpenEnterAnimation&quot;&gt;@anim/slide_in_top&lt;/item&gt; &lt;item name=&quot;Android:activityOpenExitAnimation&quot;&gt;@anim/slide_in_top&lt;/item&gt; &lt;/style&gt; 4、Android主题切换，换肤的实现 Splash白屏处理启动页是一个 APP 启动时用户第一眼看到的界面,由于Appciation在初始化还没加载出主页面基于主题会出现白屏或者黑屏 &lt;style name=&quot;AppTheme2&quot; parent=&quot;AppTheme&quot;&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@mipmap/splash&lt;/item&gt; &lt;/style&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[包名与ApplicationId]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F07%2F23%2FAndroid%2F%E4%B8%8A%E7%BA%BF%2F%E5%8C%85%E5%90%8D%E4%B8%8EApplicationId%2F</url>
    <content type="text"><![CDATA[包名、签名、ApplicationId包名、ApplicationIdEclipse中没有applicationId这个概念，在Eclipse中applicationId即等同于包名，而在Android Studio中，这两个概念做个区分。包名的定义在清单文件中： package=”com.example.myapplicationtest”应用ID是在moudle层的build.gradle中定义，applicationId值即为应用ID android { defaultConfig { applicationId &quot;com.example.myapplicationtest&quot; minSdkVersion 15 targetSdkVersion 24 versionCode 1 versionName &quot;1.0&quot; } ... } 的获取applicationId BuildConfig.APPLICATION_ID context.getApplication().getPackageName(); 通常Android的应用ID与包名是绑定的,所以在Android API中,一些方法和参数从名称上看似乎它们返回的是包名，事实上它们返回的是应用ID值.例如,Context.getPackageName()方法返回的是应用ID,而不是包名 在Android Studio中创建一个新项目时,applicationId默认是和项目的包名一致的。所以常常有开发者会将两者混淆，以为它们是一个概念。实际上,应用ID和包名是相互独立的。改变包名不会影响应用ID,反之亦然。 如果你使用了webview,请使用包名作为应用ID的前缀,否则,有可能会报错. ApplicationId 作用1、在一台测试机上同时装上开发版和发布版，只要让开发版的应用ID与发布版不一致即可 android { ... buildTypes { debug { applicationIdSuffix &quot;.debug&quot; //等同于“com.example.myapplicationtest.debug” } } 所以，debug版的应用ID为：&quot;com.example.myapplicationtest.debug&quot;. 2、构建不同的应用变体：我们发布到市场的应用希望有不同的版本，比如：免费版和收费版。 在productFlavors中进行相应的配置，来生成不同的应用,用&quot;free&quot;表示免费版，用&quot;paid&quot;表示付费版。在productFlavors中，通过配置不同应用ID，最终生成不同的应用。最终这两种应用apk可同时存在于市场中 { ... defaultConfig { applicationId &quot;com.example.myapplicationtest&quot; } productFlavors { free { applicationIdSuffix &quot;.free&quot; } paid { applicationIdSuffix &quot;.paid&quot; } ... } 签名 Android应用的签名其实指的即是根据keystore生成的MD5签名 app的签名，是通过其keystore生成的签名信息，所以前提需要有keystore文件（或者jks）,这里顺便记录： .keystore：是有Eclipse生成的 .jks： 是有android studio生成的 两者作用都是用于打包的签名，区别只是平台不同 android 有两个唯一标识，一个是包名，一个是签名。包名唯一性不多阐述，签名唯一性区别最大的就是在debug和release包下，部分第三方的平台会永不了。这就是因为默认下的debug和release下的md5签名不一样。debug下默认使用debug.jks，除非手动设置相同于release 部分平台，如微信就需要到应用的签名，获取应用签名的方式：(有区分已知keystore文件和未知的情况,第二种知道包名就可以) 1、Android studio 右上侧 gradle -&gt; 项目名称 -&gt; Tasks -&gt; android -&gt; signingReport 即可获得签名相关(Task下是所有module，单独查看某个module可以调用对应的signingReport) 2、安装签名工具.apk到手机输入包名查询 ###保持debug下的签名与release的签名一致比如，在做微信的社会化分享时，需要上传签名。这个签名应该是上传市场包的签名，免得先写debug的以后还要改回去，不如配置两种方式签名一致。配置方式：app模块下build.gradle文件中android内配置signingConfigs（jks文件放在APP模块下） android{ ... signingConfigs { release{ //release可以不写 keyAlias &apos;513bluewhale&apos; keyPassword &apos;sz513com&apos; storePassword &apos;sz513com&apos; storeFile file(&apos;bluewhale513.jks&apos;) } debug { keyAlias &apos;513bluewhale&apos; keyPassword &apos;sz513com&apos; storePassword &apos;sz513com&apos; storeFile file(&apos;bluewhale513.jks&apos;) } } ... }]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>上线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入法]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F07%2F20%2FAndroid%2FUI%2F%E8%BE%93%E5%85%A5%E6%B3%95%2F</url>
    <content type="text"><![CDATA[输入法操作1、是否已经显示 //输入法是否显示着 public static boolean KeyBoard(EditText edittext) { boolean bool = false; InputMethodManager imm = ( InputMethodManager ) edittext.getContext( ).getSystemService( Context.INPUT_METHOD_SERVICE ); if ( imm.isActive( ) ) { bool = true; } return bool; } 2、弹出 //显示虚拟键盘 public static void ShowKeyboard(View v) { InputMethodManager imm = ( InputMethodManager ) v.getContext( ).getSystemService( Context.INPUT_METHOD_SERVICE ); if(imm!=null) imm.showSoftInput(v,InputMethodManager.SHOW_FORCED); } 3、隐藏 //隐藏虚拟键盘 public static void HideKeyboard(View v) { InputMethodManager imm = ( InputMethodManager ) v.getContext( ).getSystemService( Context.INPUT_METHOD_SERVICE ); if ( imm!=null&amp;&amp;imm.isActive( ) ) { imm.hideSoftInputFromWindow( v.getApplicationWindowToken( ) , 0 ); } } 4.隐藏/显示切换 private void toggleInput(Context context){ InputMethodManager inputMethodManager = (InputMethodManager)context.getSystemService(Context.INPUT_METHOD_SERVICE); inputMethodManager.toggleSoftInput(0, InputMethodManager.HIDE_NOT_ALWAYS); } 5.点击外部隐藏输入法 @Override public boolean onTouchEvent(MotionEvent event) { // TODO Auto-generated method stub if(event.getAction() == MotionEvent.ACTION_DOWN){ if(getCurrentFocus()!=null &amp;&amp; getCurrentFocus().getWindowToken()!=null){ manager.hideSoftInputFromWindow(getCurrentFocus().getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS); } } return super.onTouchEvent(event); } SQL中的每一张表都必须设有主键吗主键的作用:1）保证实体的完整性;2）加快数据库的操作速度3）在表中添加新记录时，数据库会自动检查新记录的主键值，不允许该值与其他记录的主键值重复。4) 数据库自动按主键值的顺序显示表中的记录。如果没有定义主键，则按输入记录的顺序显示表中的记录。主键不是非要不可，可以从： 1.是否满足业务要求 2.数据查询效率（主键可以提高查询效率，当然合理的索引替代也可以） 这两个角度权衡是否需要主键。 这要看表的功能. 利用来存储大量数据,并需要经常查询的,建立主键可以加快查询效率从而降低服务器的负担. 如无此需求,建立反而多耗用服务器资源. 设置不设置主键主要看业务或者需求来说如果你就是简单的对单表操作的话，实在没有必要。对多张没有关联的表操作的话，不设置也没有什么影响主键只是说对一种表和表关系的关联而已，还有就是在建主键的时候会自动添加个索引，某些情况下可以增加查询速度 存储自定义类型对象需求场景：sqlite数据库只能直接存储数字、字符串、日期等简单类型，如果要存储一个复杂对象的话需要把对象拆解为一个个简单数据类型，毕竟再复杂的数据类型也是由简单数据类型组合而来。本以为大名鼎鼎的GreenDao可以帮我们智能拆解、组装对象，结果搜了一圈竟然找不到没找到存储自定义类型的办法。 好在在官方文档上找到解决方案： Edit输入法弹出的键盘选择 默认弹出的键盘为字母键盘： xml中：android:inputType=&quot;number&quot; 代码中：etPassword.setInputType(InputType.TYPE_TEXT_VARIATION_PASSWORD); 默认弹出的键盘为数字 xml中：android:inputType=&quot;textPassword&quot; 代码中：etPassword.setInputType(InputType.TYPE_CLASS_NUMBER); 输入字符的控制： 输入为密码： xml中： android:digits=&quot;0123456789abcdefghigklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot; 代码中：源码中并没有直接给TextView设置digits属性 ，而是使用了Editor来进行了限制，是给Editor设置了keyListener，从而实现digits属性，有直接设置KeyListener的方法，可以直接setKeyListener来设置digits属性 etPassword.setKeyListener(DigitsKeyListener.getInstance(&quot;0123456789abcdefghigklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;));]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[greenDAO总结]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F07%2F14%2FAndroid%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2Fgreen-dao%2F</url>
    <content type="text"><![CDATA[greenDAO3greenDAO 优点： 性能高，号称Android最快的关系型数据库 内存占用小 库文件比较小，小于100K，编译时间低，而且可以避免65K方法限制 支持数据库加密 greendao支持SQLCipher进行数据库加密 有关SQLCipher可以参考这篇博客Android数据存储之Sqlite采用SQLCipher数据库加密实战 简洁易用的API 配置1.依赖compile &apos;org.greenrobot:greendao:3.0.1&apos; compile &apos;org.greenrobot:greendao-generator:3.0.0&apos; 2.配置gradle// In your root build.gradle file:工程下的build.gradle dependencies { classpath &apos;com.android.tools.build:gradle:2.3.0&apos; classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.2&apos; // add plugin 添加 } buildscript { repositories { jcenter() mavenCentral() // add repository } } // In your app projects build.gradle file: app下的build.gradle apply plugin: &apos;com.android.application&apos; apply plugin: &apos;org.greenrobot.greendao&apos; // apply plugin 添加 3.在gradle中配置greenDAO相关属性greendao { schemaVersion 1 //数据库版本 daoPackage &apos;com.wyk.greendaodemo.greendao.gen&apos; //通过gradle插件生成的数据库相关文件的包名，默认为entity所在的包名 targetGenDir &apos;src/main/java&apos; //自定义生成数据库文件的目录 } 使用4.编写entity类@Entity public class User { @Id private Long id; private String name; @Transient private int tempUsageCount; // not persisted } @Entity：将我们的java普通类变为一个能够被greenDAO识别的数据库类型的实体类 @Id：通过这个注解标记的字段必须是Long类型的，这个字段在数据库中表示它就是主键，并且它默认就是自增的 @Transient：表明这个字段不会被写入数据库，只是作为一个普通的java类字段，用来临时存储数据的，不会被持久化 ####编写完entity类之后Make Project（Build菜单栏中），make完成之后greendao插件会自动生成很多代码,如果改变了已经存在的entity,记得rebuild工程保证旧的entity类被clean掉了。 5.application中初始化数据库DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(MyApplication.getContext(), &quot;notes-db&quot;, null); DaoMaster daoMaster = new DaoMaster(devOpenHelper.getWritableDatabase()); DaoSession daoSession = daoMaster.newSession(); UserDao userDao = daoSession.getUserDao(); “notes-db”是我们自定的数据库名字，应为我们之前创建了一个Entity叫做User，所以greenDAO自定帮我们生成的UserDao，拿到了这个UserDao，我们就可以操作User这张表了。 一个DaoMaster就代表着一个数据库的连接；DaoSession可以让我们使用一些Entity的基本操作和获取Dao操作类，DaoSession可以创建多个，每一个都是属于同一个数据库连接的。 一般用单例获取daoSession 6.增删改查操作(greenDAO以对象操作)//插入数据 1.插入一条数据 User user = new User(null, &quot;wyk&quot;); userDao.insert(user); 2.插入集合数据,user类型为List&lt;User&gt; DaoMaster daoMaster = new DaoMaster(getWritableDatabase()); DaoSession daoSession = daoMaster.newSession(); UserDao userDao = daoSession.getUserDao(); userDao.insertInTx(users); //查询数据 1.loadAll();----------查询所有的数据 2.条件查询---查询单个字段 获取对象-----eq方法 TaskPath taskPath = mTaskPathDao.queryBuilder().where(TaskPathDao.Properties.Task_name.eq(&quot;小红帽&quot;)).unique(); 3.条件查询---查询不是该字段内容的 对象有哪些---notEq方法 List mtaskPath = mTaskPathDao.queryBuilder().where(TaskPathDao.Properties.Task_name.notEq(&quot;小黄人&quot;)).list(); 4.条件查询--模糊查询之包含某个特殊字的查询--queryLike方法 List mtaskPath = mTaskPathDao.queryBuilder().where(TaskPathDao.Properties.Task_name.like(&quot;小%&quot;)).list(); 5.自定义查询---使用SQL语句查询 ---rawQuery方法 1.unique() // 返回唯一结果或者 null 2.list() // 返回结果集进内存 3.long count() // 获取结果数量 //更新数据，先查表中是否有此条数据 User findUser = userDao.queryBuilder().where(UserDao.Properties.Name.eq(&quot;wyk&quot;)).build().unique(); if (findUser != null) { findUser.setName(newName); userDao.update(findUser); Toast.makeText(MyApplication.getContext(), &quot;修改成功&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(MyApplication.getContext(), &quot;用户不存在&quot;, Toast.LENGTH_SHORT).show(); } //删除数据，同样先查有没有此条数据 User findUser = userDao.queryBuilder().where(UserDao.Properties.Name.eq(&quot;wyk&quot;)).build().unique(); if(findUser != null){ userDao.deleteByKey(findUser.getId()); } 注解说明实体@Entity注解 -schema：告知GreenDao当前实体属于哪个schema -active：标记一个实体处于活动状态，活动实体有更新、删除和刷新方法 -nameInDb：在数据中使用的别名，默认使用的是实体的类名 -indexes：定义索引，可以跨越多个列 -createInDb：标记创建数据库表 基础属性注解 -@Id :主键 Long型，可以通过@Id(autoincrement = true)设置自增长 -@Property：设置一个非默认关系映射所对应的列名，默认是的使用字段名 举例：@Property (nameInDb=&quot;name&quot;) -@NotNul：设置数据库表当前列不能为空 -@Transient ：添加次标记之后不会生成数据库表的列,只是作为一个普通的java类字段 索引注解 -@Index：使用@Index作为一个属性来创建一个索引，通过name设置索引别名，也可以通过unique给索引添加约束 -@Unique：向数据库列添加了一个唯一的约束 关系注解 -@ToOne：定义与另一个实体（一个实体对象）的关系 -@ToMany：定义与多个实体对象的关系 拓展 自定义sql语句 ChatHistoryDao dao = GreenDaoManager.getInstance().getSession().getChatHistoryDao(); Cursor cursor = dao.getDatabase().rawQuery(&quot;select t.sales_wx_nick_name,t.wx_nick_name,count(*),t.talker_id,t.sales_wx_account from chat_history t group by t.talker_id,t.sales_wx_account order by t.created_at desc&quot;, null); while (cursor.moveToNext()) { String salesWxNickName = cursor.getString(0); String clientWxNickName = cursor.getString(1); int chatCount = cursor.getInt(2); int talkerId = cursor.getInt(3); String salesWxAccount = cursor.getString(4); } 数据库升级 如果某张表修改了字段，或者新增了一张表，必须要修改build.gradle中的schemaVersion，否则当你升级app的时候，如果进行了数据库操作，会发现列不匹配或者表不存在等问题，直接会导致app闪退。但是如果仅仅是将schemaVersion加1，虽然程序不会崩溃，并且数据表的结构也会更新成功，但是之前表中的数据会全部清空。我们需要进行手动操作来进行数据库里面的数据迁移，大致的思路是：创建临时表（结构与上一版本的表结构相同），将旧数据移到临时表中，删除旧版本的表，创建新版本的表，将临时表中的数据转移到新表中，最后再删除临时表。详细方法见链接：http://stackoverflow.com/a/30334668/5995409 异常收录1.没有找到对应字段的列 原因：表更新如新建表需要将数据库版本更新]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[viewpager+fragment]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F07%2F06%2FAndroid%2FUI%2Fwidget%2Fnative%2Fviewpager-fragment%2F</url>
    <content type="text"><![CDATA[Fragment的切换 Fragment的方法： private void showIndex(int index) { FragmentTransaction transaction = getChildFragmentManager().beginTransaction(); List fragments = getChildFragmentManager().getFragments(); for (int i = 0; i &lt; fragments.size(); i++) { if (i == index) { transaction.show(fragments.get(i)); } else { transaction.hide(fragments.get(i)); } } transaction.commit(); } /**一个是显示一半中间线方法： * TabLayout（自定义的控件） 的中间线设置 **一半的显示** * * @param view TabLayout 对象 * @param context 当前类 * @param drawable 背景资源 */ public static void showTableLayoutDividerMiddleHalf(TabLayout view, Context context, int drawable) { //重新计算控件高度 int w = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED); int h = View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED); view.measure(w, h); LinearLayout linearLayout = (LinearLayout) view.getChildAt(0); linearLayout.setShowDividers(LinearLayout.SHOW_DIVIDER_MIDDLE);//设置样式，中间线样式 linearLayout.setDividerPadding(view.getMeasuredHeight() / 4);//设置线的大小，间隔距离上下各为1/4，也就是1/2一半的大小 int lineDrawable = R.drawable.visit_summary_bg_line;//默认背景（颜色：灰色，大小1px） if (drawable != Constants.TABLAYOUT_NORMAL) { lineDrawable = drawable; } linearLayout.setDividerDrawable(ContextCompat.getDrawable(context, lineDrawable));//设置线 } /**一个是显示全部中间线 * TabLayout（自定义的控件） 的中间线设置 显示 * * @param view TabLayout 对象 * @param context 当前类 * @param drawable 背景资源 */ public static void showTableLayoutDividerMiddle(TabLayout view, Context context, int drawable) { LinearLayout linearLayout = (LinearLayout) view.getChildAt(0); linearLayout.setShowDividers(LinearLayout.SHOW_DIVIDER_MIDDLE);//设置样式，中间线样式 int lineDrawable = R.drawable.visit_summary_bg_line;//默认背景（颜色：灰色，大小1px） if (drawable != Constants.TABLAYOUT_NORMAL) { lineDrawable = drawable; } linearLayout.setDividerDrawable(ContextCompat.getDrawable(context, lineDrawable));//设置线 } #嵌套]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生控件一些特殊设置]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F06%2F14%2FAndroid%2FUI%2F%E5%8E%9F%E7%94%9F%E6%8E%A7%E4%BB%B6%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Edittextandroid 中怎么控制EditText只能输入数字和字母？由于输入密码中设置过了密码显示和隐藏重新设置了inputtype，所以仍然可以输入中文，解决方式 &lt;EditText android:id=&quot;@+id/home_et_validate&quot; style=&quot;@style/order_vcode_input&quot; android:hint=&quot;请输入订单验证码&quot; android:inputType=&quot;number&quot; android:digits=&quot;@string/filter_vcode&quot;/&gt; &lt;string name=&quot;filter_vcode&quot;&gt;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/string&gt; #获取statusbar高度 方式一： /** * desc: 状态栏高度 */ public static int getStatusBarHeight(Context context) { int result = 0; int resourceId = context.getResources().getIdentifier(&quot;status_bar_height&quot;, &quot;dimen&quot;, &quot;android&quot;); if (resourceId &gt; 0) { result = context.getResources().getDimensionPixelSize(resourceId); } return result; } /** * desc: 状态栏高度 方式二 */ public static int getStatusBarHeight2(Context paramContext) { try { Class&lt;?&gt; localClass = Class.forName(&quot;com.android.internal.R$dimen&quot;); Object localObject = localClass.newInstance(); int i = Integer.parseInt(localClass.getField(&quot;status_bar_height&quot;).get(localObject).toString()); int j = paramContext.getResources().getDimensionPixelSize(i); return j; } catch (Exception localException) { localException.printStackTrace(); } return 0; } 方式二： private double getStatusBarHeight(Context context){ double statusBarHeight = Math.ceil(25 * context.getResources().getDisplayMetrics().density); return statusBarHeight; } 这种方法很简单，只有一行代码，查过参考手册后可以翻译一下： 状态栏高度=取大于其的最小整数（25*上下文_获取应用包的资源实例_获取当前屏幕尺寸_屏幕密度比例） 其中density并不是真实的屏幕密度，而是一个相对密度，基准密度为160dpi，比如我测试的手机为HTC one m8，查的屏幕密度为441dpi，相对160为2.75，density就取为3。各分辨率的density取值为： ldpi (dpi=120，density=0.75) mdpi (dpi=160，density=1) hdpi (dpi=240，density=1.5) xhdpi (dpi=320，density=2) xxhdpi (dpi=480，density=3) 所以得到的状态栏高度为25*3=75 由这种方法得到的状态栏高度具有较大局限性，比如因为某种需要去掉状态栏或本身没有状态栏，此时状态栏高度应为0，但是该方法依然能够得到一个非零的状态栏高度。 popup设置底部弹入弹出动画： 弹入： &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration=&quot;200&quot; android:fromYDelta=&quot;100%p&quot; android:toYDelta=&quot;0&quot; /&gt; &lt;alpha android:duration=&quot;200&quot; android:fromAlpha=&quot;0.0&quot; android:toAlpha=&quot;1.0&quot; /&gt; &lt;/set&gt; 弹出 &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration=&quot;200&quot; android:fromYDelta=&quot;0&quot; android:toYDelta=&quot;50%p&quot; /&gt; &lt;alpha android:duration=&quot;200&quot; android:fromAlpha=&quot;1.0&quot; android:toAlpha=&quot;0.0&quot; /&gt; &lt;/set&gt; TextView分段设置字体颜色1.使用SpannableString想必用过的人都知道，比较好的一点是SpannableString可以精确控制一个长长的字符串中第几个到第几个字符的样式 SpannableString spannableString = new SpannableString(&quot;jakjfkajfjaj&quot;); //设置颜色 spannableString.setSpan(new ForegroundColorSpan(Color.parseColor(&quot;#FE6026&quot;)), 3, 6, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); //设置字体大小，true表示前面的字体大小20单位为dip spannableString.setSpan(new AbsoluteSizeSpan(20, true), 0, 5, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); //设置链接 spannableString.setSpan(new URLSpan(&quot;www.baidu.com&quot;), 0, 5, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); //设置字体，BOLD为粗体 spannableString.setSpan(new StyleSpan(android.graphics.Typeface.BOLD), 0, 5, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE); 2.使用Html如果使用场景是字符串长度不固定的，比如需要服务端的数据来填充的,使用这个方式，格式比较简单，用到font标签，推荐使用这种方式 //首先是拼接字符串 String content = &quot;&lt;font color=\&quot;#FE6026\&quot;&gt;&quot; + data + &quot;&lt;/font&gt;&quot; //然后直接setText() TextView tvContent = (TextView) view.findViewById(R.id.tvContent); tvContent.setText(Html.fromHtml(content)); Android 如何使edittext默认失去焦点1.在布局文件中给edittext的父控件增加两个属性android:focusable=”true”android:focusableInTouchMode=”true” 2.直接调用edittext的clearFocus()方法，不过该方法有时候会不生效 searchView.setFocusable(true);searchView.setFocusableInTouchMode(true);searchView.requestFocus(); searchView.clearFocus();//失去焦点searchView.requestFocus();//获取焦点 随手记录感想法无论多么复杂的首页布局，其实直接用一个Rcyc就可以搞定，而且scroller中嵌套rcyc本身就是个错误，]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView（二）控制网页音乐的播放与暂停]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F06%2F11%2FAndroid%2FUI%2Fwidget%2Fnative%2FWebView%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[WebView使用（二）##控制网页音乐的播放与暂停 最近项目中有个需求，要引入一个h第三方的5为音乐库，这个音乐库播放的音乐作为背景音乐来播放，同时需要在其他页面能够控制音乐的播放与暂停。因为是别人的网页，无法与其做h5的接口交互，所以只能另想办法。因为这个需求对搜集的资料以及实现的方式做一个小结。 首先要明白Android中的音频播放的一些效果： Android的音乐流,音效流,电话声音是互不干涉的,且通过获取焦点来进行播放 多数情况下我们播放音乐都是使用 STREAM_MUSIC 音频流。 Android 2.2之后将音频播放统一在AudioManager管理 播放方式：Webview网页中中关于播放音乐是通过焦点来控制的，当点击音乐中的播放按钮的时候，播放就会获得焦点，然后取得AudioManager的控制权来播放音乐，所以做法是 解决办法:通过强行取得AudioManager的控制权来暂停播放，通过释放AudioManager的控制权来继续播放API: //获取AudioManager AudioManager audioManager = (AudioManager) getSystemService(MusicPlayer.this.AUDIO_SERVICE); //获取audiomanager控制权 public void getAudioManagerControl() { //让音乐控件失去焦点来禁止掉声音的播放 try { int i = 0; do { //焦点监听设置为自己的监听 int result = audioManager.requestAudioFocus(listener , AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN_TRANSIENT); if (result == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) { //取到控制权 Log.i(&quot;取到控制权&quot;, &quot;取到控制权&quot;); Log.d(&quot;AudioManager&quot;, &quot;I get Audio right: &quot;); break; } i++; } while (i &lt; 10); } catch (Exception ex) { ex.printStackTrace(); } } /** * desc: 控制音乐播放和暂停 */ public void controlMusic(boolean player) { if (player) { if (audioManager != null) { //释放焦点的方法 audioManager.abandonAudioFocus(listener); } } else { getAudioManagerControl(); } } AudioManager.OnAudioFocusChangeListener listener = new AudioManager.OnAudioFocusChangeListener() { @Override public void onAudioFocusChange(int focusChange) { //焦点改变 Log.d(&quot;audioManager&quot;, &quot;onAudioFocusChange: &quot; + focusChange); } }; 参考: Android WebView 停止Audio音频播放的方法 android webview中的音乐的暂停与播放 Android使用的webview中带有音乐播放控件… webview无法播放网易云等播放器的音乐网页的音乐Uncaught (in promise) NotSupportedError: The element has no supported source //添加下面两句代码的设置，就可以播放网络视频 if (Build.VERSION.SDK_INT &lt; 8) { webview.getSettings().setPluginsEnabled(true); } else { webview.getSettings().setPluginState(PluginState.ON); } if(Build.VERSION.SDK_INT&gt;= Build.VERSION_CODES.LOLLIPOP) { webview.getSettings().setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW); } 参考链接： https://blog.csdn.net/luofen521/article/details/51783914 https://blog.csdn.net/youyoulanyouyou/article/details/60955470]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>webview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView（一）]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F06%2F10%2FAndroid%2FUI%2Fwidget%2Fnative%2FWebView%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[WebView基本使用与H5交互一、介绍Native AppNative App即原生程式编写运行开发，用Android系统最初的定义进行开发 iOS: Object-C 或者 swift Android: java Web app使用HTML5编写的移动Web应用，一个webapp几乎可以不加修改的运行在PC/Android/iOS等。 优势：一套代码到处运行 劣势：某些底层功能缺失，运行速度不如原生的App hybrid app混合开发的App（Hybrid App）就是在一个App中内嵌一个轻量级的浏览器，一部分原生的功能改为Html 5来开发，这部分功能不仅能够在不升级App的情况下动态更新，而且可以在Android或iOS的App上同时运行，让用户的体验更好又可以节省开发的资源。 Hybrid开发适用于哪些功能Hybrid开发就是Native客户端中嵌入了Html App的功能，这方面微信应该是做的最好的，由于Html 5的效率以及耗电问题，我个人觉得用户是不能满足Web App的体验的，Hybrid App也只适用于某些场景。一些基础的功能，比如调用手机的摄像头，获取地理位置，登录注册功能等等，做成Native的功能，让Html 5来调用更好，这样的体验也更好。如果你把一个登录和注册功能也做成Html 5，在弱网络环境下，这个体验应该会非常的差，或许你等半天还没加载出页面。你可能会说，我可以预先加载Html 5的代码，打开App时直接加载，那么我说你在给自己找麻烦，如果要这样的话，Native开发或许更快一点。那么什么情况适合Html 5开发呢？像一些活动页面，比如秒杀、团购等适合做Html 5，因为这些页面可能涉及的非常炫而且复杂，Html 5开发或许会简单点，关键是这些页面时效性短，更新更快，因为一个活动说不定就一周时间，下周换活动，如果这样的话，你还做Native是肯定不行的 二、基本使用//不使用Android默认浏览器打开Web，就在App内部打开Web webView.setWebViewClient(new WebViewClient()); //使用websetting进行设置 WebSettings settings = webView.getSettings(); settings.setJavaScriptEnabled(true);//支持javascript settings.setUseWideViewPort(true);//适配屏幕 settings.setLoadWithOverviewMode(true); settings.setBuiltInZoomControls(true);//支持放大缩小 settings.setDisplayZoomControls(false);//隐藏放大缩小的按钮 settings.setDomStorageEnabled(true);//支持Html5标签 webView.loadUrl(&quot;https://www.cnblogs.com/codingblock/p/4742580.html&quot;);//加载网络url与本地html 三、更多使用1.返回处理如果不做返回处理会直接执行activity的返回，没有网页的返回效果 //方式1 webview webView.setOnKeyListener(new View.OnKeyListener() { @Override public boolean onKey(View v, int keyCode, KeyEvent event) { if (event.getAction() == KeyEvent.ACTION_DOWN) { if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; webView.canGoBack()) { //表示按返回键 webView.goBack(); //后退 return true; //已处理 } } return false; } }); //方式2 activity @Override public boolean onKeyDown(int keyCode, KeyEvent event) { if(keyCode==KeyEvent.KEYCODE_BACK&amp;&amp;mWebView.canGoBack()){ mWebView.goBack(); return true; } return super.onKeyDown(keyCode, event); } 加载进度方式1-进度条，重写WebChromeClient： class MyChromeClient extends WebChromeClient{ @Override public void onProgressChanged(WebView view, int newProgress){ //这里做进度处理 if (newProgress == 100) { pbWebLoad.setVisibility(View.GONE); } else { if (View.GONE == pbWebLoad.getVisibility()) { pbWebLoad.setVisibility(View.VISIBLE); } pbWebLoad.setProgress(newProgress); } super.onProgressChanged(view, newProgress); } } 记得要webView.setWebChromeClient（MyChromeClient）//设置webchromeclient 方式2-loading框，重写WebViewClient： private class MyWebViewClient extends WebViewClient{ @Override public void onPageStarted(WebView view, String url, Bitmap favicon) { super.onPageStarted(view, url, favicon); //弹Loading框进行加载 } @Override public void onPageFinished(WebView view, String url) { super.onPageFinished(view, url); //消失Loading框，加载完毕 } } webView.setWebViewClient（MyWebViewClient） 刷新：wvTest.reload(); 错误页面-在网页加载失败、没有网络的情况下WebView会把加载的网页地址显示出来。为了避免这种情况，我们需要重写webviewclient： class MyWebViewClient extends WebViewClient{ @Override public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) { super.onReceivedError(view, errorCode, description, failingUrl); //在这里进行加载错误、没有网络情况的处理 //方式1：加载一个本地的默认页面 wvTest.loadData(&quot;file:///android_asset/refresh/refresh.html&quot;); //方式2：显示一个默认布局 tvDefault.setText(&quot;网页加载失败&quot;); wvTest.setVisibility(View.GONE); } } wvTest.setWebViewClient(new MyWebViewClient()); 第二种情况：网页地址有误，比如放入百度音乐进去音乐详情界面点击下载会提示报错 webview只能识别http, https这样的协议，像一些微信(weixin://)、去哪儿(qunaraphone://)，他们自定义的协议webView是无法识别的，因此就会出现：ERR_UNKNOWN_URL_SCHEME这样的错误。 net：ERR_UNKNOWN_URL_SCHEME” 遇到无法打开的协议，处理方法是在shouldOverrideUrlLoading里面加判断 iew.setWebViewClient(new WebViewClient() { @Override public boolean shouldOverrideUrlLoading(WebView view, String url) { if (url == null) return false; try{ if(!url.startsWith(&quot;http://&quot;) &amp;&amp; !url.startsWith(&quot;https://&quot;)){ Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url)); startActivity(intent); return true; } }catch (Exception e){//防止crash (如果手机上没有安装处理某个scheme开头的url的APP, 会导致crash) LogUtil.i(&quot;网页错误&quot;); return true;//没有安装该app时，返回true，表示拦截自定义链接，但不跳转，避免弹出上面的错误页面 } // TODO Auto-generated method stub //返回值是true的时候控制去WebView打开，为false调用系统浏览器或第三方浏览器 view.loadUrl(url); return true; } }); 清空缓存public static void clearCache(Context context) { CookieSyncManager cookieSyncMngr = CookieSyncManager.createInstance(context); CookieManager cookieManager = CookieManager.getInstance(); cookieManager.removeAllCookie(); context.deleteDatabase(&quot;webview.db&quot;); context.deleteDatabase(&quot;webviewCache.db&quot;); context.deleteDatabase(&quot;webviewCookiesChromium.db&quot;); context.deleteDatabase(&quot;webviewCookiesChromiumPrivate.db&quot;); //WebView 缓存文件 File webviewCacheDir = new File(context.getCacheDir().getAbsolutePath()+&quot;/webviewCacheChromium&quot;); //删除webview 缓存目录 if(webviewCacheDir.exists()){ deleteFile(webviewCacheDir); } } 下载文件wvTest.setDownloadListener(new DownloadListener() { @Override public void onDownloadStart(String url, String userAgent, String contentDisposition, String mimetype, long contentLength) { //需要下载的文件的地址就是url，及可以下载文件 } //调用系统浏览器去下载文件（updateUrl是下载地址）： Intent intent= new Intent(); intent.setAction(&quot;android.intent.action.VIEW&quot;); Uri content_url = Uri.parse(updateUrl); intent.setData(content_url); startActivity(Intent.createChooser(intent, &quot;请选择浏览器&quot;)); 四、Android与前端交互1.导入html文件-main文件夹下新建assets文件夹，用于存放html相关文件 2.html代码&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; function fun1(){ document.getElementById(&quot;content&quot;).innerHTML = &quot;JAVA调用了JS的无参函数&quot;; } function fun2(arg){ document.getElementById(&quot;content&quot;).innerHTML = arg; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;window.android.jSFunction()&quot;&gt;点击调用Android代码&lt;/button&gt; &lt;button onclick=&quot;window.android.jSFunction(&apos;的点点滴滴多多多多多多多&apos;)&quot;&gt;点击调用Android代码，包含参数&lt;/button&gt; &lt;p id=&quot;content&quot;&gt;内容显示&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; 3.Android代码：webview设置 webView.getSettings().setJavaScriptEnabled(true);//支持App内部javascript交互 webView.loadUrl(&quot;file:///android_asset/test.html&quot;);//加载assets下的html文件 JavascriptInterface: //由于安全原因,targetSdkVersion&gt;=17需要加 @JavascriptInterface //JS调用Android JAVA方法名和HTML中的按钮 onclick后的别名后面的名字对应 @JavascriptInterface public void jSFunction() {// Log.i(&quot;=============&quot;, &quot;jSFunction()&quot;); getActivity().runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(getActivity(), &quot;JS调用&quot;, Toast.LENGTH_LONG).show(); } }); } @JavascriptInterface public void jSFunction(final String msg) {// Log.i(&quot;=============&quot;, &quot;jSFunction(msg)&quot;); getActivity().runOnUiThread(new Runnable() { @Override public void run() { Toast.makeText(getActivity(), msg, Toast.LENGTH_LONG).show(); } }); } Andorid调用JS： webView.loadUrl(&quot;javaScript:fun1()&quot;); JS调用安卓： &lt;button onclick=&quot;window.android.jSFunction()&quot;&gt;点击调用Android代码&lt;/button&gt; webView.addJavascriptInterface(this, &quot;android&quot;);//js调用Android设置,参数一是调用方法的类对象，参数二是标识 // jSFunction（）方法]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConstranintLayout]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F05%2F25%2FAndroid%2FMaterial%20Design%2FConstranintLayout%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[ConstraintLayout ConstraintLayout，称为约束性布局，Google:2017I/O大会上重点推出来的功能，非常适合使用可视化的方式来编写界面,使用方式有点类似于RelativeLayout，可以当做是其升级版本。 扁平化设计，减少层级嵌套，加快布局速度 Android Studio3.0后已经默认xml根标签为ConstraintLayout 一、使用（一）定位 ConstraintLayout 能够灵活地定位和调整子View的大小，子 View 依靠约束关系来确定位置。在一个约束关系中，需要有一个 Source（源）以及一个 Target（目标），Source 的位置依赖于 Target，可以理解为“通过约束关系，Source 与 Target链接在了一起，Source 相对于 Target 的位置便是固定的了 参照。 每个控件有四个方向的约束，根据这四个方向的属性设置其位置 layout_constraintXXX_toYYYOf 格式的属性，表示View A”的方向 XXX 置于 “View B”的方向 YYY 。当中，View B 可以是父容器即 ConstraintLayout ，用“parent”来表示，如：app：layout_constraintRight_toLeftOf=”@+id/text”,表示此控件在text的左边 app:layout_constraintBaseline_toBaselineOf （View A 内部文字与 View B 内部文字对齐） app:layout_constraintLeft_toLeftOf （View A 与 View B 左对齐） app:layout_constraintLeft_toRightOf （View A 的左边置于 View B 的右边） app:layout_constraintRight_toLeftOf （View A 的右边置于 View B 的左边） app:layout_constraintRight_toRightOf app:layout_constraintTop_toTopOf app:layout_constraintTop_toBottomOf app:layout_constraintBottom_toTopOf app:layout_constraintBottom_toBottomOf app:layout_constraintStart_toEndOf app:layout_constraintStart_toStartOf app:layout_constraintEnd_toStartOf app:layout_constraintEnd_toEndOf 水平居中： app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; 垂直居中： app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; 约束强度 依靠 layout_constraintHorizontal_bias 和 layout_constraintVertical_bias 两个属性，即用来设置控件在水平和垂直方向的偏移量 （二）指示线当需要一个任意位置的锚点时，可以使用指示线（Guideline）来帮助定位，指示线实际上是 View 的子类，使用方式和普通的 View 相同，但指示线有着如下的特殊属性： 宽度和高度均为0 可见性为 View.GONE，只是在布局的时候帮助其他view做约束来定位的，不会出现在实际页面中 可以选择使用百分比或实际距离来设置指示线的偏移位置，此外也可以通过 orientation 属性来设置指示线的方向 &lt;! --android:orientation app:layout_constraintGuide_end app:layout_constraintGuide_begin -&gt; &lt;android.support.constraint.Guideline android:id=&quot;@+id/guideline1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot; app:layout_constraintGuide_percent=&quot;0.5&quot; /&gt; &lt;android.support.constraint.Guideline android:id=&quot;@+id/guideline2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot; app:layout_constraintGuide_begin=&quot;100dp&quot; /&gt; （三）Chains链 如果几个View之间通过双向连接而互相约束对方的位置，那么将其视为链条,链条的最左侧视为链头，通过设置链头来决定这个链的展示效果。 1、我对他的理解是控制多个view使用不同的连接方式来分配剩余空间，当做weight的加强版 链条可以分为水平和竖直，对应的方向分配此方向上的空间分布，用layout_constraintHorizontal_chainStyle和layout_constraintVertical_chainStyle两个属性来设置，属性值有三种,属性值设置给链头的View： layout_constraintHorizontal_chainStyle，layout_constraintVertical_chainStyle 属性值设置给链头的View： spread ：均匀展开，居中并且均分空白空间，根据控件宽高属性值为0或者自适应有不同效果，可理解为weight并居中 spread_inside ：可理解为weight链头链尾贴边，其余居中 packed ：可理解为view居中相连 默认为spread 各个参数值的效果: 2、效果展示（默认的spread，weight效果）: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;com.czy.constraintlayoutdemo.MainActivity&quot;&gt; &lt;TextView android:id=&quot;@+id/tv1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;#f5ec7e&quot; android:gravity=&quot;center&quot; android:text=&quot;Hello World!&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/tv2&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintHorizontal_chainStyle=&quot;spread&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;50dp&quot; android:layout_marginTop=&quot;0dp&quot; android:background=&quot;#ff538c&quot; android:gravity=&quot;center&quot; android:text=&quot;Hello World!&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/tv1&quot; app:layout_constraintRight_toLeftOf=&quot;@+id/tv3&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; &lt;TextView android:id=&quot;@+id/tv3&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;#41c0ff&quot; android:gravity=&quot;center&quot; android:text=&quot;Hello World!&quot; app:layout_constraintLeft_toRightOf=&quot;@+id/tv2&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt; &lt;/android.support.constraint.ConstraintLayout&gt; （四）宽高比控件自身宽高比app:layout_constraintDimensionRatio 1、设置控件的宽高比例,需要至少设置宽度或者高度为0 2、如果宽度和高度都是 0dp ，系统会使用满足所有约束条件和宽高比率值的最大尺寸,可理解为match-parent 3、如果要根据其中一个尺寸来约束另外一个尺寸，则可以在比率值的前面添加 W 或者 H 来指明约束宽度或者高度如： app:layout_constraintDimensionRatio=&quot;2:1&quot; //宽高比为2：1 app:layout_constraintDimensionRatio=&quot;h,2:1&quot; //表示以高度为基准，宽高比是2：1，展示结果是宽度是高度的2倍 app:layout_constraintDimensionRatio=&quot;W,2:1&quot; //表示以宽度为基准，展示结果是高度是宽度的2倍 子控件宽高比像LinearLayout 一样为子控件设置 layout_weight 属性，从而控件子控件之间的宽高占比 app:layout_constraintHorizontal_weight app:layout_constraintVertical_weight 二、属性记录：app:layout_constraintBaseline_toBaselineOf （View A 内部文字与 View B 内部文字对齐） app:layout_constraintLeft_toLeftOf （View A 与 View B 左对齐） app:layout_constraintLeft_toRightOf （View A 的左边置于 View B 的右边） app:layout_constraintRight_toLeftOf （View A 的右边置于 View B 的左边） app:layout_constraintRight_toRightOf app:layout_constraintTop_toTopOf app:layout_constraintTop_toBottomOf app:layout_constraintBottom_toTopOf app:layout_constraintBottom_toBottomOf app:layout_constraintStart_toEndOf app:layout_constraintStart_toStartOf app:layout_constraintEnd_toStartOf app:layout_constraintEnd_toEndOf 水平居中： app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; 垂直居中： app:layout_constraintTop_toTopOf=&quot;parent&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; 宽高比： app:layout_constraintVertical_weight app:layout_constraintHorizontal_weight app:layout_constraintDimensionRatio=&quot;h,2:1&quot; //表示以高度为基准，宽高比是2：1，展示结果是宽度是高度的2倍 app:layout_constraintDimensionRatio=&quot;W,2:1&quot; //表示以宽度为基准，展示结果是高度是宽度的2倍 偏移： layout_constraintHorizontal_bias layout_constraintVertical_bias Guideline: android:orientation app:layout_constraintGuide_begin app:layout_constraintGuide_end app:layout_constraintGuide_percent Chains: layout_constraintVertical_chainStyle layout_constraintVertical_chainStyle 对齐这里只列出水平方向，竖直方向同理两个控件底部对齐: app:layout_constraintBaseline_toBaselineOf=&quot;&quot; 两个控件中心点对齐(有点类似控件居中的写法，锁定一个控件)： app:layout_constraintTop_toTopOf=&quot;@+id/view2&quot; app:layout_constraintBottom_toBottomOf=&quot;@id/view2&quot; 百分比布局++宽高设置为wrapcontent 与0dp 与matchparent 区别 三、内容参照：基本属性和操作：Android ConstraintLayout 使用详解 可视化操作： 郭霖的专栏:ConstraintLayout完全解析 ConstraintLayout ConstraintLayout深入系列之中心点对齐 Constraintlayout补充1、避免出现约束的问题。一个控件建立约束 一定要建立在绝对不会gone的view上面 添加约束的时候要注意约束的对象会不会gone，一旦gone就会出现布局混乱了。所以约束的对象尽量要是一直可见的。实在做不到的时候也只能设置一个同大小的空view去占位了]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>material design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义控件-组合控件]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F05%2F19%2FAndroid%2F%E5%9F%BA%E7%A1%80%2F%E8%87%AA%E5%AE%9A%E4%B9%89%2F%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E5%90%88%E6%8E%A7%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[自定义控件-组合控件用途：对于有相似或者相同的布局并且含有嵌套的布局，比如我的页面下的每个item，app标题栏，就可以使用自定义组合控件，简洁代码，降低开发成本 使用1、新建xml设置自己的基本布局，布局完后将跟布局设置为merge &lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; ... &lt;/merge&gt; &lt;!--为何要使用merge标签，自定义组合控件时会继承RelativeLayout、LinearLayout等控件，这样导致布局的层级无形中增加了一层--&gt; 2、建立自定义view类继承自xml的根布局，重写2参构造方法，获取xml中控件实例 //LayouInflater三参数在这里的作用,后面两个能直接绑定为此view根布局 View view = LayoutInflater.from(context).inflate(R.layout.custom_groups_1, this, true); tvTopName = view.findViewById(R.id.tvTopName); tvTopNumber = view.findViewById(R.id.tvTopNumber); tvLeft = view.findViewById(R.id.tvLeft); seekbar = view.findViewById(R.id.seekbar); tvRight = view.findViewById(R.id.tvRight); 3、自定义属性，values下新建attrs文件，新建declare-stylable标签自定义属性，名字保持和自定义的类名一致 &lt;declare-styleable name=&quot;CustomGroupViewAttunement1&quot;&gt; &lt;attr name=&quot;text_top_number&quot; format=&quot;string|reference&quot; /&gt; &lt;attr name=&quot;text_top_name&quot; format=&quot;string|reference&quot; /&gt; &lt;attr name=&quot;text_left&quot; format=&quot;string|reference&quot; /&gt; &lt;attr name=&quot;rightIsImg&quot; format=&quot;boolean&quot; /&gt; &lt;!--这里是用于右边text是放文字还是图片 --&gt; &lt;attr name=&quot;text_right&quot; format=&quot;reference|string&quot; /&gt; &lt;attr name=&quot;ibutton_clickable&quot; format=&quot;boolean&quot; /&gt; &lt;attr name=&quot;ibutton_select&quot; format=&quot;boolean&quot; /&gt; &lt;/declare-styleable&gt; 4、回到自定义view中，设置具体属性，使用完后释放TypedArray TypedArray attributes = context.obtainStyledAttributes(attrs, R.styleable.CustomGroupViewAttunement1); if (attributes != null) { //顶部text显示 tvTopName.setText(attributes.getString(R.styleable.CustomGroupViewAttunement1_text_top_name)); tvLeft.setText(attributes.getString(R.styleable.CustomGroupViewAttunement1_text_left)); boolean rightIsImg = attributes.getBoolean(R.styleable.CustomGroupViewAttunement1_rightIsImg, true);//默认是图片 tvRight.setSelected(true); if (rightIsImg) { //设置左边图片或者文字 int rightDrawable = attributes.getResourceId(R.styleable.CustomGroupViewAttunement1_text_right, R.mipmap.unmute);//图片用获取资源id tvRight.setBackground(getResources().getDrawable(rightDrawable)); } else { tvRight.setText(attributes.getString(R.styleable.CustomGroupViewAttunement1_text_right)); } tvRight.setClickable(attributes.getBoolean(R.styleable.CustomGroupViewAttunement1_ibutton_clickable, false));//默认不可点击 attributes.recycle(); } 6、xml中直接引用]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发（三）- 第三方库整理]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F05%2F10%2FAndroid%2F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2FAndroid%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[开发中常用的第三方库整理(持续更新)##推荐安装的插件，可以自动搜索依赖 一、EventBus二、ButterKnife]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>异常收录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发（二）-IDE:Android Studio整理]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F05%2F03%2FAndroid%2F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2FAndroid%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89-IDE%2F</url>
    <content type="text"><![CDATA[Android开发（二）-IDE:Android Studio整理AndroidStudio官方下载地址(国外)需翻墙 AndroidStudio官方下载地址(国内) AndroidStudio中文社区下载 软件面板介绍 部分操作记录setting里面有搜索，如果要设置可以直接搜索设置卡在gradle building:Android Studio导入项目的时候，需要下载项目对应的gradle包，主因为在国内防火墙屏蔽的原因，导致下载的速度蜗牛般慢，所以会一直卡停在这个界面 方法一：修改项目的gradle-wrapper.properties里的gradle版本把原有的gradle-xx-all.zip包修改为当前版本，如果不知道值为多少，找一个你之前能够运行的AS项目，然后在文件夹下找到gradle-wrapper.properties，复制distributionUrl属性。在新的项目中找到build.grable修改为其值，重启Android Studio即可 方法一：离线包下载导入原因是自动下载不成功，那么我们可以手动下载回来，然后进行导入进去，查看所需gradle版本，打开C:\Users\用户名.gradle\wrapper\dists\gradle-x.xx-all\xxxxxxxxxxxx如果里面的gradle-xx-all.zip不完整（如0KB），则说明下载不成功，需要下载离线包放置到该目录下,也可以直接去导入的项目中查看设置的gradle 版本gradle版本下载 个性化log字体设置1.File-&gt;Settings 或Ctrl + Alt +S 2.找到 Editor -&gt; Colors &amp;Fonts -&gt; Android Logcat 或在上面的搜索框中输入Logcat 3.点中Verbose , Info, Debug等选项，然后在后面将Use Inberited attributes 去掉勾选 4.再将 Foreground 前的复选框选上，就可以双击后面的框框去选择颜色了 5.Apply–&gt;OK 推荐色值： 注释模板 新建类注释 setting -&gt; File and Code Templates -&gt;Include -&gt;File Header 方法快捷键注释 setting -&gt; Live Templates -&gt; + Template Group(新建组) -&gt; + Live Template (建快捷注释) 常用快捷键（传送）ctrl + r //替换 ctrl + shift + r //全局替换 shift + f6 //文件重命名 home/end //调到行首/尾 ctrl + 左/右方向 //调到单词头/尾 ctrl + d //复制当前行 ctrl + y //删除当前行 ctrl + alt + l // 格式化代码]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发（一）- 环境配置]]></title>
    <url>%2FAaronYang23.github.io%2F2018%2F05%2F01%2FAndroid%2F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2FAndroid%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Android开发-环境Java环境配置 安装JDK，安装前会先安装JRE: 下载地址， 现在下载需要登录：迅雷下载链接：https://download.oracle.com/otn/java/jdk/8u221-b11/230deb18db3e4014bb8e3e8324f81b43/jdk-8u221-windows-x64.exe?AuthParam=1563589007_663a1f07ff53f2baa3925f340f025ad7 配置环境变量： JAVA_HOME：变量值填写JDK的安装路径，如 D:\Java\jdk1.8.0_25 CLASSPATH：将jdk安装目录下的lib子目录中的dt.jar和tools.jar设置到CLASSPATH中，变量值为： .;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; PATH: ;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin 注：path路径是cmd时会到PATH变量所指定的路径中查找看是否能找到相应的命令程序，为了以后adb调试方便，建议将adb也加入到path中，就无须再去cd入adb所在目录中。 测试：运行cmd 分别输入java，javac， java -version Android Studio安装（目前Android studio安装可以不用安装java，安装包自带jre） 安装：下载地址 选择是否导入配置文件 卡在程序在检查SDK的更新情况： 通过如下操作： （1）在Android Studio安装目录下的 bin 目录下，找到 idea.properties 文件； （2）在文件最后追加disable.android.first.run=true 。 （3）”跳过这一步。如果你后期需要更新SDK，可点击上面的“二、资源下载”中最后的那个红色链接，下载需要的安装包离线进行配置。 sdk进打开sdk选项自行下载个人风格配置 主题：Preference -&gt; Appearance下更改主题到Darcula。 字体:Settings中Editor–&gt;Colors&amp;Fonts–&gt;Font，在Scheme name中选择Darcula就能变成酷炫又护眼的黑色界面，然后点击Save As…，取一个新名字，并根据预览界面的效果选择一个合适的Size数值，即可完成字体的修改 log字体颜色：File-&gt;Settings搜索font找到Colors &amp;Fonts -&gt; Android Logcat ,去掉勾选Use Inberited attributes 修改颜色。 Assert(AF5858)、Debug(B697BB)、Error(FF7F7D)、Info(88BB6E)、Warning(BBBB23) 注释模板设置 文件头注释：setting&gt;搜索 file and cod template&gt;includes&gt;File Header，description下面有插入的字段解释 方法注释：只用最简单的快捷注释描述方法功能:setting&gt;keymap&gt;other&gt;Fix doc comment&gt;add shortcut 卡在Gradle:Build Running的解决： 一般是因为要下载对应版本的gradle: 1.找到C:\Users\Administrator.gradle\wrapper\dists，查看gradle版本号, 下载相应版本。例如：gradle-2.4-all.zip，放于底层目录下,不要解压。 也可以使用打开gradle/wrapper/gradle-wrapper.properties文件用迅雷新建下载distributionUrl后的地址。 2.将gradle设置为离线模式:setting-&gt;gradle：勾选Use default，Offline work,一般第一步重启就可以 Genymotion###安装 安装,需要同时安装VirtualBox，下载前先注册，注册过的直接登录。下载地址 安装完成后配置VirtualBox 下载虚拟机（genymotion的时候都是等了很久才能下载完成，并且有时候会下载失败） 推荐离线下载，使用办法如下： 首先点击界面上的+号（Add）按钮，选择你要下载的模拟器虚拟机版本，点击下载（一定要走这一步，不然会影响下面的步骤） 然后到C:\Users\Administrator\AppData\Local\Genymobile\下面打开genymotion.log文件，找到Downloading file后面的http开头的链接，复制到迅雷开始下载； 下载完成之后拷贝这个文件（称为文件1）到C:\Users\Administrator\AppData\Local\Genymobile\Genymotion\ova。然后你会看到里面已经存在一个.ova文件，（这个文件就是你刚才第一步选择下载的那个，自动下载的，暂且称为文件2），把文件2的文件名复制到文件 1上（记得删除文件2）。 重新打开genymotion模拟器，和刚才步骤1一样的步骤，你会发现很快就可以加载好了，接下来就可以愉快的使用模拟器了 Genymotion插件：setting-&gt; plugin 搜索Genymotion，安装后设置好genymotion的安装目录 ###错误总结 使用5.0以上时卡在启动界面，报错the number of cpus of the virtual device has been forced to be 1：原因是系统禁用了多核虚拟技术。 大神解决1 大神解决2 如果5.0以上的模拟器一直打不开，网络各种调了没用。切记要在virtualbox中设置模拟器常规为windows类型，默认是Linux. 参考传送门 AS有许多好用的插件，点击传送]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hack So ！！！]]></title>
    <url>%2FAaronYang23.github.io%2F2017%2F10%2F10%2FGit%2FHexoBlog%2FHello%20Hack%20So%20!%2F</url>
    <content type="text"><![CDATA[今天是建好博客的第一天，关于此博客，我先立一个小flag： 1、如何写好博客，博客的编排与风格； 2、我的博客内容模块的设计：技术，摘录，感悟随笔。。 3、目前是用的别人的主题，以后要设计自己的博客站风格。 用Hexo创建个人博客指引（链接）： -初始化:http://www.jianshu.com/p/b06222fbc135 -主题更换:http://blog.csdn.net/qq_18661793/article/details/51864416 -部署至Github Page：http://www.jianshu.com/p/9d2e241a0cd4 -本地访问地址:http://localhost:4000/ 基本使用：-hexo new “Hello”-hexo generate-hexo server更新:(拷贝public/目录下的文件)-cd username.github.io-git add -A-git commit -m “Add blog file.” git push -u origin masterps:-修改日志博客内容本地的会即时更新不需要在generate，但是根目录下的配置需要。 总结：有自己的小窝了!!!]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown]]></title>
    <url>%2FAaronYang23.github.io%2F2017%2F10%2F10%2FGit%2FHexoBlog%2FMarkDown%2F</url>
    <content type="text"><![CDATA[#MrakDown语法 基本语法：标题 分级标题：#、##、### 加粗：两个个星号包裹：粗体 斜体：一个星号包裹：斜体 列表 无序列表：- 在要子列表就加两空格 有序列表: 1.2. 分割线 三个星号”***”或者”-“ 引用 引入文字 文字前面加”&gt;” 引入代码 方式一:换行加tab ArrayList list1 = (ArrayList) allListData.get(0).getBooks(); adapter1.setNewData(list1); 方式二：使用&lt;blockquote&gt;。（不是单引号而是左上角的ESC下面~中的）ArrayList&lt;BookBean&gt; list1 = (ArrayList&lt;BookBean&gt;) allListData.get(0).getBooks(); 引入标记文字或者会被翻译的md语句块 用包裹 链接 插入链接： 链接为[](),ex:百度 图片 基本写法： 比插入链接多一个非号：![]() 插入url: ![描述&amp;未加载显示的图片]{url} 插入本地图片，可选绝对和相对路径，推荐写相对路径 如果图片与.md文件在同一目录下 其父路径用“..”表示，例如 ![avatar](../buildWebsites.jpg) 或者: ![图片出错](../_posts/blogimages/1.jpg) 另外markdown在写hexo网页时，相对路径既可以从当前位置起步识别，也可以从主题下的resource文件里开始匹配。 通过这些方式，你可以轻松的通过相对路径定位到图片的任意一个位置。 ps:写。。之后的描述路径从当前文件所在的父文件夹开始,../即表示当前文件的父文件夹,如果在子文件夹下，贼用多个../回溯 修改宽高：![描述](url){:height=&quot;50%&quot; width=&quot;50%&quot;} `![描述](url){:height=&quot;100px&quot; width=&quot;400px&quot;}` hexo: `&lt;img src=&quot;url&quot; width=&quot;自定义的宽&quot;,heigt=&quot;自定义的高&quot;&gt;` 居中显示： `&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;url&quot; width=&quot;自定义的宽&quot;,heigt=&quot;自定义的高&quot;&gt;&lt;/div&gt;` 表格 表头 表头 单元格 单元格 单元格 单元格 左对齐标题 右对齐标题 居中对齐标题 短文本 中等文本 稍微长一点的文本 稍微长一点的文本 短文本 中等文本 ###编辑工具推荐 Mac推荐： Mou Windows推荐:MarkdownPad,被很多人称赞为windows 平台最好用的markdown编辑器。 在线编辑器： Chrome 插件:Marxico ,中文名马克飞象 StackEdit 作业部落]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 工具收录]]></title>
    <url>%2FAaronYang23.github.io%2F2016%2F10%2F10%2FAndroid%2F%E8%A7%84%E8%8C%83%E5%92%8C%E6%9B%B4%E5%A4%9A%E4%BD%BF%E7%94%A8%2F%E7%BD%91%E7%AB%99%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[工具 翻墙工具：蓝灯 Android相关 Pro Git（中文版) AndroidCat Developers 开源代码： 安卓巴士 GitHub 资讯: Stack Overflow 掘金 简书 UI设计类网址收藏 SDC设计师网站导航 语言&amp;学习 达人课 RunOOB-菜鸟教程 搜索类 必应]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
